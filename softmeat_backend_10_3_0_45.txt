# Estrutura do Projeto SoftMeat - backend

├── public
│   ├── uploads
│   │   ├── Clientes
│   │   ├── Cursos
│   │   ├── Produtos
│   │   │   ├── Bacon
│   │   │   ├── Blumenau
│   │   │   ├── Copa
│   │   │   ├── Pastrami
│   │   │   └── Salame
│   │   ├── Testemunhos
├── src
│   ├── admin
│   ├── api
│   │   ├── carrossel-treinamento
│   │   │   ├── content-types
│   │   │   │   └── carrossel-treinamento
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── cliente
│   │   │   ├── content-types
│   │   │   │   └── cliente
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── configuracao-geral
│   │   │   ├── content-types
│   │   │   │   └── configuracao-geral
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── cronograma
│   │   │   ├── content-types
│   │   │   │   └── cronograma
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── curso-online
│   │   │   ├── content-types
│   │   │   │   └── curso-online
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── hero-consultoria
│   │   │   ├── content-types
│   │   │   │   └── hero-consultoria
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── home-consultoria
│   │   │   ├── content-types
│   │   │   │   └── home-consultoria
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── home-hero
│   │   │   ├── content-types
│   │   │   │   └── home-hero
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── home-treinamento
│   │   │   ├── content-types
│   │   │   │   └── home-treinamento
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── index-destaque
│   │   │   ├── content-types
│   │   │   │   └── index-destaque
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── media-reference
│   │   │   ├── controllers
│   │   │   └── routes
│   │   ├── produto
│   │   │   ├── content-types
│   │   │   │   └── produto
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── sobre-carrossel
│   │   │   ├── content-types
│   │   │   │   └── sobre-carrossel
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── testemunho
│   │   │   ├── content-types
│   │   │   │   └── testemunho
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── treinamento
│   │   │   ├── content-types
│   │   │   │   └── treinamento
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   ├── extensions
│   │   ├── upload
│   ├── middlewares
│   ├── provider
│   │   └── r2-upload
│   ├── utils
├── .env
├── package.json


.env

# Configuração do Servidor
HOST=0.0.0.0
PORT=1337
APP_KEYS=2VJlAoWpXfzDHzGqX7IVTA==,QSdu6uWUfiOcoPe5SgRI+w==,I9GT5I/hmBtES9PgklJFow==,W6LM3JinQfZ6BN/+u5aFSA==
API_TOKEN_SALT=isFissNnC7p/4U1GpNnMDA==
ADMIN_JWT_SECRET=E4rq8HGv9avD80L7hXY8TA==
TRANSFER_TOKEN_SALT=EQ/v2sGIMohFSsL9Tg7gww==
JWT_SECRET=vDZKwN6GXEPTfdIC8Aijrg==
DATABASE_CLIENT=sqlite
DATABASE_FILENAME=/mnt/data/softmeat-db/data.db
URL=http://localhost:1337
PUBLIC_URL=http://localhost:1337
WEBHOOKS_POPULATE_RELATIONS=false

# R2 Configuration
R2_ACCESS_KEY=c5a5705f56ec2c7d0198c9b712eda3c4
R2_SECRET_KEY=f01299d076461e261024d2778df30f9e23e6b74674633efa918798a58b806d33
R2_ENDPOINT=https://950693b7edbd202561c3d20e4a036247.r2.cloudflarestorage.com
R2_BUCKET=softmeat-storage
R2_REGION=auto
R2_PUBLIC_URL=https://storage.softmeat.com.br


backups\20250309\extensions\extensions\upload\middlewares\imageProcessor.js

// src/extensions/upload/middlewares/imageProcessor.js (versão simplificada para produção)
'use strict';

const sharp = require('sharp');
const fs = require('fs');

module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    // Em produção, logging detalhado
    if (ctx.request.url.includes('/upload') && ctx.request.method === 'POST') {
      const files = ctx.request.files?.files || [];

      if (files.length > 0) {
        for (const file of files) {
          if (file && file.type && file.type.startsWith('image/')) {
            try {
              // Apenas verificar se a imagem é válida sem modificá-la
              const metadata = await sharp(file.path).metadata();
              console.log(`[PROD] Imagem verificada: ${file.name}, formato: ${metadata.format}, tamanho: ${file.size} bytes`);

              // Verificar se o arquivo tem conteúdo
              const stats = fs.statSync(file.path);
              if (stats.size === 0) {
                console.error(`[PROD ERROR] Arquivo vazio detectado: ${file.name}`);
              } else {
                console.log(`[PROD] Arquivo válido: ${file.name}, tamanho: ${stats.size} bytes`);
              }
            } catch (error) {
              console.error(`[PROD ERROR] Falha ao verificar imagem ${file.name}: ${error.message}`);
            }
          }
        }
      }
    }

    // Prosseguir sem processar a imagem para evitar problemas
    await next();
  };
};


backups\20250309\extensions\extensions\upload\services\format-url.js

'use strict';

/**
 * Serviço aprimorado para formatação de URLs do R2
 */

/**
 * Extrai o domínio de uma URL
 * @param {string} url - URL para extrair o domínio
 * @returns {string} Domínio da URL
 */
function extractDomain(url) {
  if (!url) return '';
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (error) {
    console.error(`[R2 URL] Erro ao extrair domínio: ${error.message}`);
    return '';
  }
}

/**
 * Formata URL de arquivo para usar o domínio público do R2
 * @param {Object} file - Objeto de arquivo
 * @returns {Object} Arquivo com URL atualizada
 */
function formatFileUrl(file) {
  if (!file || !file.url) return file;

  try {
    // Obter configurações do R2
    const publicDomain = process.env.CF_PUBLIC_ACCESS_URL;
    const r2Endpoint = process.env.CF_ENDPOINT;
    const bucket = process.env.CF_BUCKET;

    if (!publicDomain) {
      console.log(`[R2 URL] Domínio público não configurado, mantendo URL original: ${file.url}`);
      return file;
    }

    // Log para depuração
    console.log(`[R2 URL] Processando URL: ${file.url}`);

    const currentDomain = extractDomain(file.url);
    const publicUrlDomain = extractDomain(publicDomain);

    // Se já estiver usando o domínio público, manter como está
    if (currentDomain === publicUrlDomain) {
      console.log(`[R2 URL] URL já usa domínio público, mantendo: ${file.url}`);
      return file;
    }

    // Verificar se está usando o endpoint R2 direto
    const isUsingR2Endpoint = r2Endpoint && file.url.includes(r2Endpoint);

    // Se não estiver usando endpoint R2 nem domínio público, pode ser URL externa
    if (!isUsingR2Endpoint && currentDomain !== publicUrlDomain) {
      console.log(`[R2 URL] Possível URL externa, verificando estrutura: ${file.url}`);

      // Verificar se é uma URL válida
      try {
        new URL(file.url);
      } catch (e) {
        console.log(`[R2 URL] URL inválida, mantendo como está: ${file.url}`);
        return file;
      }

      // Se o domínio for diferente e não for do R2, é provavelmente uma URL externa
      // Preserva-la se for válida
      if (!currentDomain.includes('cloudflarestorage.com') &&
          !currentDomain.includes('softmeat.com.br')) {
        console.log(`[R2 URL] URL externa confirmada, mantendo: ${file.url}`);
        return file;
      }
    }

    // Se chegamos aqui, precisamos reformatar a URL para usar o domínio público

    // Extrair o caminho relativo da URL
    let relativePath = '';
    try {
      const urlObj = new URL(file.url);
      relativePath = urlObj.pathname;

      // Remover prefixo do bucket se presente
      if (bucket && relativePath.includes(bucket)) {
        const bucketIndex = relativePath.indexOf(bucket);
        relativePath = relativePath.substring(bucketIndex + bucket.length);
      }

      // Remover barras iniciais
      while (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
    } catch (error) {
      console.error(`[R2 URL] Erro ao extrair caminho: ${error.message}`);
      return file;
    }

    // Formar nova URL com domínio público
    const formattedPublicDomain = publicDomain.endsWith('/')
      ? publicDomain.slice(0, -1)
      : publicDomain;

    const newUrl = `${formattedPublicDomain}/${relativePath}`;

    console.log(`[R2 URL] URL reformatada: ${file.url} -> ${newUrl}`);

    // Criar cópia do arquivo com URL atualizada
    return {
      ...file,
      url: newUrl
    };
  } catch (error) {
    console.error(`[R2 URL] Erro ao formatar URL: ${error.message}`);
    // Em caso de erro, retornar arquivo original sem modificações
    return file;
  }
}

module.exports = {
  formatFileUrl
};


backups\20250309\extensions\extensions\upload\strapi-server.js

'use strict';

module.exports = (plugin) => {
  const originalUpload = plugin.services.upload.upload;

  // Função para verificar se uma URL é do R2
  const isR2Url = (url) => {
    const patterns = [
      'storage.softmeat.com.br',
      '.r2.cloudflarestorage.com',
      process.env.R2_PUBLIC_URL,
      process.env.R2_ENDPOINT,
    ].filter(Boolean);

    return url && patterns.some(pattern => url.includes(pattern));
  };

  // Sobrescrever o método de upload
  plugin.services.upload.upload = async (fileData, config) => {
    // Se for uma URL externa do R2, apenas referenciar sem fazer upload
    if (fileData && fileData.fileInfo && fileData.fileInfo.url && isR2Url(fileData.fileInfo.url)) {
      console.log(`[R2] URL externa detectada: ${fileData.fileInfo.url}`);

      // Extrair informações do arquivo
      const fileName = fileData.fileInfo.url.split('/').pop();
      const ext = getExtension(fileName);
      const mime = getMimeType(ext);

      // Retornar objeto sem fazer upload (apenas referência)
      return {
        name: fileName || fileData.fileInfo.name,
        url: fileData.fileInfo.url,
        provider: 'aws-s3',
        ext: ext || fileData.fileInfo.ext,
        mime: mime || fileData.fileInfo.mime,
        size: fileData.fileInfo.size || 0,
        isExternalUrl: true
      };
    }

    // Caso contrário, continuar com o upload normal
    return await originalUpload(fileData, config);
  };

  // Interceptar para normalizar URLs nas respostas
  const originalFindOne = plugin.services.upload.findOne;
  if (originalFindOne) {
    plugin.services.upload.findOne = async (id, config) => {
      const file = await originalFindOne(id, config);

      if (file && file.url && isR2Url(file.url)) {
        file.url = formatR2Url(file.url);
      }

      return file;
    };
  }

  // Interceptar para normalizar URLs nas listagens
  const originalFind = plugin.services.upload.find;
  if (originalFind) {
    plugin.services.upload.find = async (params, config) => {
      const files = await originalFind(params, config);

      if (Array.isArray(files)) {
        files.forEach(file => {
          if (file.url && isR2Url(file.url)) {
            file.url = formatR2Url(file.url);
          }
        });
      }

      return files;
    };
  }

  return plugin;
};

// Função para formatar URLs R2
function formatR2Url(url) {
  if (!url) return url;

  const publicUrl = process.env.R2_PUBLIC_URL || 'https://storage.softmeat.com.br';

  // Se já estiver usando o domínio público
  if (url.includes(publicUrl)) return url;

  try {
    // Extrair o caminho relativo
    let relativePath = '';
    const urlObj = new URL(url);
    const bucketName = process.env.R2_BUCKET || 'softmeat-storage';

    // Tentar diferentes formatos de URL
    if (url.includes('.r2.cloudflarestorage.com')) {
      const parts = urlObj.pathname.split('/');
      const bucketIndex = parts.findIndex(part => part === bucketName);

      if (bucketIndex >= 0 && bucketIndex < parts.length - 1) {
        relativePath = parts.slice(bucketIndex + 1).join('/');
      }
    } else {
      // Formato simples de URL
      relativePath = urlObj.pathname;
      if (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
    }

    if (relativePath) {
      const cleanPublicUrl = publicUrl.endsWith('/') ?
                            publicUrl.slice(0, -1) :
                            publicUrl;
      return `${cleanPublicUrl}/${relativePath}`;
    }

    return url;
  } catch (error) {
    console.error(`[R2] Erro ao formatar URL: ${error.message}`);
    return url;
  }
}

// Funções auxiliares
function getExtension(filename) {
  if (!filename) return '';
  const parts = filename.split('.');
  return parts.length > 1 ? `.${parts.pop().toLowerCase()}` : '';
}

function getMimeType(ext) {
  if (!ext) return 'application/octet-stream';

  const types = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.svg': 'image/svg+xml',
    '.pdf': 'application/pdf',
    '.doc': 'application/msword',
    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    '.xls': 'application/vnd.ms-excel',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    '.ppt': 'application/vnd.ms-powerpoint',
    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    '.mp4': 'video/mp4',
    '.mp3': 'audio/mpeg',
    '.wav': 'audio/wav',
    '.zip': 'application/zip',
    '.txt': 'text/plain',
    '.csv': 'text/csv',
    '.json': 'application/json',
  };

  return types[ext.toLowerCase()] || 'application/octet-stream';
}


backups\20250309\extensions\upload\middlewares\imageProcessor.js

// src/extensions/upload/middlewares/imageProcessor.js (versão simplificada para produção)
'use strict';

const sharp = require('sharp');
const fs = require('fs');

module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    // Em produção, logging detalhado
    if (ctx.request.url.includes('/upload') && ctx.request.method === 'POST') {
      const files = ctx.request.files?.files || [];

      if (files.length > 0) {
        for (const file of files) {
          if (file && file.type && file.type.startsWith('image/')) {
            try {
              // Apenas verificar se a imagem é válida sem modificá-la
              const metadata = await sharp(file.path).metadata();
              console.log(`[PROD] Imagem verificada: ${file.name}, formato: ${metadata.format}, tamanho: ${file.size} bytes`);

              // Verificar se o arquivo tem conteúdo
              const stats = fs.statSync(file.path);
              if (stats.size === 0) {
                console.error(`[PROD ERROR] Arquivo vazio detectado: ${file.name}`);
              } else {
                console.log(`[PROD] Arquivo válido: ${file.name}, tamanho: ${stats.size} bytes`);
              }
            } catch (error) {
              console.error(`[PROD ERROR] Falha ao verificar imagem ${file.name}: ${error.message}`);
            }
          }
        }
      }
    }

    // Prosseguir sem processar a imagem para evitar problemas
    await next();
  };
};


backups\20250309\extensions\upload\services\format-url.js

'use strict';

/**
 * Serviço aprimorado para formatação de URLs do R2
 */

/**
 * Extrai o domínio de uma URL
 * @param {string} url - URL para extrair o domínio
 * @returns {string} Domínio da URL
 */
function extractDomain(url) {
  if (!url) return '';
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (error) {
    console.error(`[R2 URL] Erro ao extrair domínio: ${error.message}`);
    return '';
  }
}

/**
 * Formata URL de arquivo para usar o domínio público do R2
 * @param {Object} file - Objeto de arquivo
 * @returns {Object} Arquivo com URL atualizada
 */
function formatFileUrl(file) {
  if (!file || !file.url) return file;

  try {
    // Obter configurações do R2
    const publicDomain = process.env.CF_PUBLIC_ACCESS_URL;
    const r2Endpoint = process.env.CF_ENDPOINT;
    const bucket = process.env.CF_BUCKET;

    if (!publicDomain) {
      console.log(`[R2 URL] Domínio público não configurado, mantendo URL original: ${file.url}`);
      return file;
    }

    // Log para depuração
    console.log(`[R2 URL] Processando URL: ${file.url}`);

    const currentDomain = extractDomain(file.url);
    const publicUrlDomain = extractDomain(publicDomain);

    // Se já estiver usando o domínio público, manter como está
    if (currentDomain === publicUrlDomain) {
      console.log(`[R2 URL] URL já usa domínio público, mantendo: ${file.url}`);
      return file;
    }

    // Verificar se está usando o endpoint R2 direto
    const isUsingR2Endpoint = r2Endpoint && file.url.includes(r2Endpoint);

    // Se não estiver usando endpoint R2 nem domínio público, pode ser URL externa
    if (!isUsingR2Endpoint && currentDomain !== publicUrlDomain) {
      console.log(`[R2 URL] Possível URL externa, verificando estrutura: ${file.url}`);

      // Verificar se é uma URL válida
      try {
        new URL(file.url);
      } catch (e) {
        console.log(`[R2 URL] URL inválida, mantendo como está: ${file.url}`);
        return file;
      }

      // Se o domínio for diferente e não for do R2, é provavelmente uma URL externa
      // Preserva-la se for válida
      if (!currentDomain.includes('cloudflarestorage.com') &&
          !currentDomain.includes('softmeat.com.br')) {
        console.log(`[R2 URL] URL externa confirmada, mantendo: ${file.url}`);
        return file;
      }
    }

    // Se chegamos aqui, precisamos reformatar a URL para usar o domínio público

    // Extrair o caminho relativo da URL
    let relativePath = '';
    try {
      const urlObj = new URL(file.url);
      relativePath = urlObj.pathname;

      // Remover prefixo do bucket se presente
      if (bucket && relativePath.includes(bucket)) {
        const bucketIndex = relativePath.indexOf(bucket);
        relativePath = relativePath.substring(bucketIndex + bucket.length);
      }

      // Remover barras iniciais
      while (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
    } catch (error) {
      console.error(`[R2 URL] Erro ao extrair caminho: ${error.message}`);
      return file;
    }

    // Formar nova URL com domínio público
    const formattedPublicDomain = publicDomain.endsWith('/')
      ? publicDomain.slice(0, -1)
      : publicDomain;

    const newUrl = `${formattedPublicDomain}/${relativePath}`;

    console.log(`[R2 URL] URL reformatada: ${file.url} -> ${newUrl}`);

    // Criar cópia do arquivo com URL atualizada
    return {
      ...file,
      url: newUrl
    };
  } catch (error) {
    console.error(`[R2 URL] Erro ao formatar URL: ${error.message}`);
    // Em caso de erro, retornar arquivo original sem modificações
    return file;
  }
}

module.exports = {
  formatFileUrl
};


backups\20250309\extensions\upload\strapi-server.js

// src/extensions/upload/strapi-server.js
'use strict';

module.exports = (plugin) => {
  const originalUpload = plugin.services.upload.upload;

  // Função para verificar se uma URL é do R2
  const isR2Url = (url) => {
    const patterns = [
      'images.softmeat.com.br',
      '.r2.cloudflarestorage.com',
      process.env.R2_PUBLIC_URL,
      process.env.R2_ENDPOINT,
    ].filter(Boolean);

    return url && patterns.some(pattern => url.includes(pattern));
  };

  // Função para converter URLs diretas do R2 para o domínio personalizado
  const formatR2Url = (url) => {
    if (!url || !isR2Url(url)) return url;

    const publicUrl = process.env.R2_PUBLIC_URL || 'https://images.softmeat.com.br';

    // Se já estiver usando o domínio público
    if (url.includes(publicUrl)) return url;

    try {
      // Extrair o caminho relativo
      let relativePath = '';
      const urlObj = new URL(url);
      const bucketName = process.env.R2_BUCKET || 'softmeat-prod';

      // Tentar diferentes formatos de URL
      if (url.includes('.r2.cloudflarestorage.com')) {
        const parts = urlObj.pathname.split('/');
        const bucketIndex = parts.findIndex(part => part === bucketName);

        if (bucketIndex >= 0 && bucketIndex < parts.length - 1) {
          relativePath = parts.slice(bucketIndex + 1).join('/');
        }
      } else {
        // Formato simples de URL
        relativePath = urlObj.pathname;
        if (relativePath.startsWith('/')) {
          relativePath = relativePath.substring(1);
        }
      }

      if (relativePath) {
        const cleanPublicUrl = publicUrl.endsWith('/') ?
                              publicUrl.slice(0, -1) :
                              publicUrl;
        return `${cleanPublicUrl}/${relativePath}`;
      }

      return url;
    } catch (error) {
      console.error(`[R2] Erro ao formatar URL: ${error.message}`);
      return url;
    }
  };

  // Sobrescrever o método de upload
  plugin.services.upload.upload = async (fileData, config) => {
    // Se tiver uma URL e for do R2, apenas referenciar
    if (fileData && fileData.url && isR2Url(fileData.url)) {
      console.log(`[R2] URL externa detectada: ${fileData.url}`);

      // Normalizar a URL
      const normalizedUrl = formatR2Url(fileData.url);
      console.log(`[R2] URL normalizada: ${normalizedUrl}`);

      // Extrair informações do arquivo
      const fileName = normalizedUrl.split('/').pop();
      const ext = getExtension(fileName);
      const mime = getMimeType(ext);

      // Retornar objeto sem fazer upload (apenas referência)
      return {
        ...fileData,
        url: normalizedUrl,
        provider: 'aws-s3',
        name: fileName || fileData.name,
        ext: ext || fileData.ext,
        mime: mime || fileData.mime,
        size: fileData.size || 0,
        isExternalUrl: true
      };
    }

    // Caso contrário, continuar com o upload normal
    return await originalUpload(fileData, config);
  };

  // Interceptar para normalizar URLs nas respostas
  const originalFindOne = plugin.services.upload.findOne;
  if (originalFindOne) {
    plugin.services.upload.findOne = async (id, config) => {
      const file = await originalFindOne(id, config);

      if (file && file.url && isR2Url(file.url)) {
        file.url = formatR2Url(file.url);
      }

      return file;
    };
  }

  // Interceptar para normalizar URLs nas listagens
  const originalFind = plugin.services.upload.find;
  if (originalFind) {
    plugin.services.upload.find = async (params, config) => {
      const files = await originalFind(params, config);

      if (Array.isArray(files)) {
        files.forEach(file => {
          if (file.url && isR2Url(file.url)) {
            file.url = formatR2Url(file.url);
          }
        });
      }

      return files;
    };
  }

  return plugin;
};

// Funções auxiliares
function getExtension(filename) {
  if (!filename) return '';
  const parts = filename.split('.');
  return parts.length > 1 ? `.${parts.pop()}` : '';
}

function getMimeType(ext) {
  if (!ext) return 'application/octet-stream';

  const types = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.svg': 'image/svg+xml',
  };

  return types[ext.toLowerCase()] || 'application/octet-stream';
}


backups\20250309\middlewares.js

module.exports = ({ env }) => [
  'strapi::errors',
  {
    name: 'strapi::security',
    config: {
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          'connect-src': [
            "'self'",
            'https:',
            'http:',
            env("CF_ENDPOINT", "").replace(/^https?:\/\//, ""),
            env("CF_PUBLIC_ACCESS_URL", "").replace(/^https?:\/\//, ""),
            '*.r2.cloudflarestorage.com'
          ],
          'img-src': [
            "'self'",
            'data:',
            'blob:',
            'dl.airtable.com',
            env("CF_ENDPOINT", "").replace(/^https?:\/\//, ""),
            env("CF_PUBLIC_ACCESS_URL", "").replace(/^https?:\/\//, ""),
            '*.r2.cloudflarestorage.com',
            '*.cloudflare.com',
            '*.softmeat.com.br',
            'market-assets.strapi.io',
            '*'  // Temporariamente permissivo durante testes
          ],
          'media-src': [
            "'self'",
            'data:',
            'blob:',
            'dl.airtable.com',
            env("CF_ENDPOINT", "").replace(/^https?:\/\//, ""),
            env("CF_PUBLIC_ACCESS_URL", "").replace(/^https?:\/\//, ""),
            '*.r2.cloudflarestorage.com',
            '*.cloudflare.com',
            '*.softmeat.com.br',
            'market-assets.strapi.io',
            '*'  // Temporariamente permissivo durante testes
          ],
          'script-src': ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          'frame-ancestors': null,
          upgradeInsecureRequests: null,
        },
      },
      frameguard: false,
    },
  },
  {
    name: 'strapi::body',
    config: {
      jsonLimit: '10mb',
      formLimit: '50mb',
      textLimit: '10mb',
      formidable: {
        maxFileSize: 50 * 1024 * 1024, // 50MB
        multiples: true,
        keepExtensions: true
      },
    },
  },
  {
    name: 'strapi::cors',
    config: {
      headers: '*',
      origin: [
        'http://localhost:1337',
        'http://localhost:3000',
        'http://localhost:4321',
        'https://softmeat.com.br',
        'https://www.softmeat.com.br',
        'https://softmeat-backend-production.up.railway.app',
        'https://softmeat.pages.dev',
        env("CF_PUBLIC_ACCESS_URL", "https://images.softmeat.com.br"),
        env("CF_ENDPOINT", "")
      ].filter(Boolean),
      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'],
      keepHeaderOnError: true,
      credentials: true,
      maxAge: 31536000,
      exposedHeaders: ['Content-Range', 'X-Content-Range']
    },
  },
  // Remover temporariamente o middleware personalizado
  // {
  //   name: 'global::imageR2Handler',
  //   config: {}
  // },
  'strapi::poweredBy',
  'strapi::logger',
  'strapi::query',
  'strapi::body',
  'strapi::session',
  'strapi::favicon',
  'strapi::public',
];


backups\20250309\plugins.js

// config/plugins.js
const path = require('path');

module.exports = ({ env }) => ({
  'users-permissions': {
    config: {
      jwtSecret: env('JWT_SECRET'),
    },
  },
  upload: {
    config: {
      provider: '@strapi/provider-upload-aws-s3',
      providerOptions: {
        accessKeyId: env('R2_ACCESS_KEY'),
        secretAccessKey: env('R2_SECRET_KEY'),
        region: env('R2_REGION', 'auto'),
        endpoint: env('R2_ENDPOINT'),
        params: {
          Bucket: env('R2_BUCKET'),
          ACL: 'public-read',
        },
        customDomain: env('R2_PUBLIC_URL')
      },
      actionOptions: {
        upload: {
          ACL: 'public-read',
          customPath: (file) => {
            // Função para sanitizar strings
            const sanitizeString = (str) => {
              if (!str) return '';
              return str
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove acentos
                .replace(/[^\w\-]/g, '-')        // Substitui caracteres especiais por hífen
                .replace(/\-+/g, '-')            // Remove hífens consecutivos
                .toLowerCase();                   // Converte para minúsculas
            };

            // Se for uma URL externa, retornar a URL completa sem modificação
            if (file.isExternalUrl && file.url) {
              return file.url;
            }

            // Detectar o tipo de recurso
            const resourceType = file.mime?.startsWith('image/') ? 'images' :
                               file.mime?.startsWith('video/') ? 'videos' :
                               file.mime?.startsWith('audio/') ? 'audios' : 'files';

            // Determinar a categoria com base no contexto do upload
            let category = 'geral';

            // Tentar determinar a categoria baseado no tipo de conteúdo relacionado
            if (file.related) {
              // Extrair o modelo de relacionamento
              const relatedType = file.related.split('.')[0];

              // Mapeamento simplificado de categorias
              const categoryMap = {
                'produto': 'produtos',
                'curso-online': 'cursos',
                'testemunho': 'testemunhos',
                'cliente': 'clientes',
                'hero-consultoria': 'consultoria',
                'home-consultoria': 'consultoria',
                'home-hero': 'index',
                'index-destaque': 'index',
                'sobre-carrossel': 'institucional',
                'carrossel-treinamento': 'testemunhos',
                'treinamento': 'treinamentos',
                'cronograma': 'treinamentos',
                'home-treinamento': 'treinamentos',
                'configuracao-geral': 'logo'
              };

              // Obter categoria do mapeamento ou usar 'geral' como fallback
              category = categoryMap[relatedType] || 'geral';
            }

            // Sanitizar a categoria
            category = sanitizeString(category);

            // Gerar nome de arquivo sem caracteres especiais mas mantendo a extensão
            const nameWithoutExt = path.basename(file.name, file.ext);
            const sanitizedName = sanitizeString(nameWithoutExt);
            const extension = file.ext.startsWith('.') ? file.ext.substring(1) : file.ext;

            // Evitar nomes muito longos, limitando a 30 caracteres + extensão
            const truncatedName = sanitizedName.length > 30
              ? sanitizedName.substring(0, 30)
              : sanitizedName;

            // Garantir que o hash seja único e esteja presente
            const shortHash = (file.hash || Date.now().toString()).substring(0, 8);

            // Gerar o nome final do arquivo
            const fileName = `${truncatedName}-${shortHash}.${extension}`;

            // Caminho completo no formato categoria/nome-arquivo
            const finalPath = `${category}/${fileName}`;

            if (env('DEBUG') === 'true') {
              console.log('[Upload Path]', {
                original: file.name,
                category: category,
                path: finalPath
              });
            }

            return finalPath;
          }
        },
        uploadStream: {
          ACL: 'public-read'
        },
        delete: {},
      },
    },
  },
});


config\admin.js

module.exports = ({ env }) => ({
  auth: {
    secret: env('ADMIN_JWT_SECRET'),
  },
  apiToken: {
    salt: env('API_TOKEN_SALT'),
  },
  transfer: {
    token: {
      salt: env('TRANSFER_TOKEN_SALT'),
    },
  },
  flags: {
    nps: env.bool('FLAG_NPS', false),
    promoteEE: env.bool('FLAG_PROMOTE_EE', false),
  },
  watchIgnoreFiles: [
    '**/config/sync/**',
  ],
});


config\api.js

module.exports = {
  rest: {
    defaultLimit: 25,
    maxLimit: 100,
    withCount: true,
  },
  responses: {
    privateAttributes: ['_v', 'id', 'created_at'],
  },
  webhook: {
    populateRelations: false,
  },
};


config\database.js

const path = require("path");

module.exports = ({ env }) => ({
  connection: {
    client: 'sqlite',
    connection: {
      filename: env('DATABASE_FILENAME', '/mnt/data/softmeat-db/data.db'),
      useNullAsDefault: true,
    },
    useNullAsDefault: true,
    pool: {
      min: 0,
      max: 1,
      acquireTimeoutMillis: 600000,
      createTimeoutMillis: 600000,
      destroyTimeoutMillis: 600000,
      idleTimeoutMillis: 600000,
    }
  }
});


config\functions\bootstrap.js

'use strict';

module.exports = () => {
  // Função de bootstrap
  strapi.log.info('Starting Strapi server...');

  // Configurações iniciais
  strapi.log.info('Checking database connection...');

  // Log de configurações importantes
  strapi.log.info(`Server URL: ${strapi.config.get('server.url', 'not set')}`);
  strapi.log.info(`Database Client: ${strapi.config.get('database.connection.client', 'not set')}`);
  strapi.log.info(`Database Path: ${strapi.config.get('database.connection.connection.filename', 'not set')}`);
};


config\middlewares\debug.js

// config/middlewares/debug.js
module.exports = (config, { strapi }) => {
  strapi.log.info("============ DEBUG ENVIRONMENT VARIABLES ============");
  strapi.log.info("R2_ENDPOINT:", process.env.R2_ENDPOINT);
  strapi.log.info("R2_BUCKET:", process.env.R2_BUCKET);
  strapi.log.info("R2_CUSTOM_DOMAIN:", process.env.R2_CUSTOM_DOMAIN);

  return async (ctx, next) => {
    // Continuar para o próximo middleware
    await next();
  };
};


config\middlewares\r2.js

module.exports = ({ env }) => ({
  settings: {
    r2Storage: {
      enabled: true,
      config: {
        provider: '@strapi/provider-upload-aws-s3',
        providerOptions: {
          accessKeyId: env('R2_ACCESS_KEY'),
          secretAccessKey: env('R2_SECRET_KEY'),
          endpoint: env('R2_ENDPOINT'),
          params: {
            Bucket: env('R2_BUCKET'),
          },
          region: env('R2_REGION', 'auto'),
        },
      },
    },
  },
});


config\middlewares.js

module.exports = [
  'strapi::errors',
  {
    name: 'strapi::security',
    config: {
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          'img-src': ["'self'", 'data:', 'blob:', 'storage.softmeat.com.br', '*.r2.cloudflarestorage.com'],
          'media-src': ["'self'", 'data:', 'blob:', 'storage.softmeat.com.br', '*.r2.cloudflarestorage.com'],
        },
      },
    },
  },
  'strapi::cors',
  'strapi::poweredBy',
  'strapi::logger',
  'strapi::query',
  'strapi::body',
  'strapi::session',
  'strapi::favicon',
  'strapi::public',
];


config\plugins.js

module.exports = ({ env }) => ({
  upload: {
    config: {
      provider: '@strapi/provider-upload-aws-s3',
      providerOptions: {
        accessKeyId: env('R2_ACCESS_KEY'),
        secretAccessKey: env('R2_SECRET_KEY'),
        endpoint: env('R2_ENDPOINT'),
        params: {
          Bucket: env('R2_BUCKET'),
          ACL: 'public-read',
        },
        region: env('R2_REGION', 'auto'),
        baseUrl: env('R2_PUBLIC_URL')
      },
      breakpoints: {
        xlarge: 1920,
        large: 1000,
        medium: 750,
        small: 500,
        xsmall: 64
      },
    },
  },
});


config\server.js

module.exports = ({ env }) => ({
  host: env('HOST', '0.0.0.0'),
  port: env.int('PORT', 1337),
  url: env('PUBLIC_URL', 'https://softmeat-backend-production.up.railway.app'),
  app: {
    keys: env.array('APP_KEYS'),
  },
  // Configurações de timeout
  emitErrors: false,
  maxUploadLimit: '50mb',
  maxRequestSize: '50mb',
  http2: {
    enabled: false,
  },
  webhooks: {
    populateRelations: false,
  },
  // Timeouts
  timeout: 120000,
});


package.json

{
  "name": "backend",
  "private": true,
  "version": "0.1.0",
  "description": "A Strapi application",
  "scripts": {
    "develop": "strapi develop",
    "start": "NODE_ENV=production strapi start",
    "build": "strapi build",
    "strapi": "strapi"
  },
  "dependencies": {
    "@strapi/plugin-i18n": "4.12.0",
    "@strapi/plugin-users-permissions": "4.12.0",
    "@strapi/provider-upload-aws-s3": "^4.12.0",
    "@strapi/strapi": "4.12.0",
    "aws-sdk": "^2.1095.0",
    "better-sqlite3": "8.0.1",
    "sharp": "^0.30.7",
    "strapi-plugin-import-export-entries": "^1.23.1"
  },
  "author": {
    "name": "A Strapi developer"
  },
  "strapi": {
    "uuid": "3289c097-8983-4dc0-817c-2192d4dfd468"
  },
  "engines": {
    "node": ">=14.19.1 <=18.x.x",
    "npm": ">=6.0.0"
  },
  "license": "MIT",
  "devDependencies": {
    "@aws-sdk/client-s3": "^3.188.0",
    "dotenv": "^16.4.7",
    "mime-types": "^2.1.35"
  }
}


scripts\check-r2-url.js

// scripts/check-r2-url.js
require('dotenv').config();

// Função para verificar se uma URL é do R2
function isR2Url(url) {
  const r2Patterns = [
    'images.softmeat.com.br',
    '.r2.cloudflarestorage.com',
    process.env.CF_PUBLIC_ACCESS_URL,
    process.env.R2_CUSTOM_DOMAIN,
    'softmeat-dev',
    'softmeat-prod'
  ].filter(Boolean);

  return r2Patterns.some(pattern => pattern && url.includes(pattern));
}

// Função para normalizar URL R2
function normalizeR2Url(url) {
  if (!url || !isR2Url(url)) return url;

  const publicUrl = process.env.CF_PUBLIC_ACCESS_URL || 'https://images.softmeat.com.br';

  // Já usa o domínio público?
  if (url.startsWith(publicUrl)) {
    return url;
  }

  // Extrair caminho relativo
  let relativePath = '';

  if (url.includes('.r2.cloudflarestorage.com')) {
    const match = url.match(/.*\/([^/]+)\/(.*)$/);
    if (match && match[2]) {
      relativePath = match[2];
    }
  }

  if (relativePath) {
    const cleanPublicUrl = publicUrl.endsWith('/') ? publicUrl.slice(0, -1) : publicUrl;
    return `${cleanPublicUrl}/${relativePath}`;
  }

  return url;
}

// URLs de teste
const testUrls = [
  'https://images.softmeat.com.br/produtos/bacon-12345.jpg',
  'https://950693b7edbd202561c3d20e4a036247.r2.cloudflarestorage.com/softmeat-dev/produtos/salame-67890.png',
  'https://950693b7edbd202561c3d20e4a036247.r2.cloudflarestorage.com/softmeat-prod/images/test.jpg',
  'https://example.com/imagem.jpg'
];

// Testar cada URL
console.log('=== TESTE DE DETECÇÃO E NORMALIZAÇÃO DE URLS R2 ===');
console.log('Variáveis de ambiente carregadas:');
console.log('CF_PUBLIC_ACCESS_URL:', process.env.CF_PUBLIC_ACCESS_URL);
console.log('CF_ENDPOINT:', process.env.CF_ENDPOINT);
console.log('CF_BUCKET:', process.env.CF_BUCKET);

testUrls.forEach(url => {
  const isR2 = isR2Url(url);
  const normalized = normalizeR2Url(url);

  console.log(`\nURL: ${url}`);
  console.log(`É URL do R2? ${isR2 ? 'SIM' : 'NÃO'}`);

  if (isR2) {
    console.log(`URL normalizada: ${normalized}`);
    console.log(`Mudou? ${url !== normalized ? 'SIM' : 'NÃO'}`);
  }
});

// Executar com: node scripts/check-r2-url.js


scripts\checkExternalUrl.js

'use strict';

// Middleware que verifica se uma URL é externa e evita o processamento desnecessário
module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    // Apenas interceptar uploads
    if (ctx.request.url.includes('/upload') && ctx.request.method === 'POST') {
      const fileData = ctx.request.body.fileInfo;

      // Verificar se é uma URL externa do R2
      if (fileData && fileData.url) {
        const r2Patterns = [
          'images.softmeat.com.br',
          '.r2.cloudflarestorage.com',
          process.env.CF_PUBLIC_ACCESS_URL,
          process.env.R2_CUSTOM_DOMAIN
        ].filter(Boolean);

        const isR2Url = r2Patterns.some(pattern =>
          fileData.url && fileData.url.includes(pattern)
        );

        if (isR2Url) {
          // Marcar como URL externa
          ctx.request.body.fileInfo.isExternalUrl = true;
          console.log(`[R2 Middleware] URL R2 detectada: ${fileData.url}`);
        }
      }
    }

    await next();
  };
};


scripts\copy-r2-buckets.js

const dotenv = require('dotenv');
const { S3Client, ListObjectsV2Command, GetObjectCommand, PutObjectCommand } = require('@aws-sdk/client-s3');

dotenv.config();

// Configurações
const SOURCE_BUCKET = 'softmeat-dev';
const TARGET_BUCKET = 'softmeat-prod';
const DRY_RUN = true; // Definir como false para realmente copiar os objetos

// Log inicial
console.log('=== CÓPIA DE OBJETOS ENTRE BUCKETS R2 ===');
console.log(`De: ${SOURCE_BUCKET}`);
console.log(`Para: ${TARGET_BUCKET}`);
console.log(`Modo: ${DRY_RUN ? 'Simulação (dry run)' : 'Cópia real'}`);

// Verificar credenciais
if (!process.env.CF_ACCESS_KEY_ID || !process.env.CF_ACCESS_SECRET) {
  console.error('Erro: Credenciais R2 não configuradas!');
  process.exit(1);
}

// Criar cliente R2
const r2Client = new S3Client({
  region: process.env.CF_REGION || 'auto',
  endpoint: process.env.CF_ENDPOINT,
  credentials: {
    accessKeyId: process.env.CF_ACCESS_KEY_ID,
    secretAccessKey: process.env.CF_ACCESS_SECRET,
  }
});

// Função para copiar objetos entre buckets
async function copyBucketObjects() {
  try {
    console.log('\nListando objetos do bucket de origem...');

    // Listar objetos no bucket de origem
    const listCommand = new ListObjectsV2Command({
      Bucket: SOURCE_BUCKET
    });

    const sourceObjects = await r2Client.send(listCommand);

    if (!sourceObjects.Contents || sourceObjects.Contents.length === 0) {
      console.log('Nenhum objeto encontrado no bucket de origem.');
      return;
    }

    console.log(`Encontrados ${sourceObjects.Contents.length} objetos para copiar.`);

    // Listar objetos no bucket de destino para verificar quais já existem
    console.log('Verificando objetos existentes no bucket de destino...');

    const targetListCommand = new ListObjectsV2Command({
      Bucket: TARGET_BUCKET
    });

    let targetObjects;
    try {
      targetObjects = await r2Client.send(targetListCommand);
    } catch (error) {
      console.error('Erro ao listar objetos do bucket de destino:', error.message);
      targetObjects = { Contents: [] };
    }

    // Criar conjunto de chaves existentes no destino
    const existingKeys = new Set();
    if (targetObjects.Contents) {
      targetObjects.Contents.forEach(obj => existingKeys.add(obj.Key));
    }

    console.log(`O bucket de destino já possui ${existingKeys.size} objetos.`);

    // Copiar objetos
    let copiedCount = 0;
    let skippedCount = 0;
    let errorCount = 0;

    for (const obj of sourceObjects.Contents) {
      // Verificar se o objeto já existe no destino
      if (existingKeys.has(obj.Key)) {
        console.log(`Pulando objeto existente: ${obj.Key}`);
        skippedCount++;
        continue;
      }

      try {
        // Obter o objeto do bucket de origem
        const getCommand = new GetObjectCommand({
          Bucket: SOURCE_BUCKET,
          Key: obj.Key
        });

        const sourceObject = await r2Client.send(getCommand);

        if (!DRY_RUN) {
          // Copiar para o bucket de destino
          const putCommand = new PutObjectCommand({
            Bucket: TARGET_BUCKET,
            Key: obj.Key,
            Body: sourceObject.Body,
            ContentType: sourceObject.ContentType,
            ContentLength: sourceObject.ContentLength,
            ACL: 'public-read',
            CacheControl: 'public, max-age=31536000, immutable'
          });

          await r2Client.send(putCommand);
        }

        console.log(`${DRY_RUN ? '[Simulação] ' : ''}Copiado: ${obj.Key} (${obj.Size} bytes)`);
        copiedCount++;
      } catch (error) {
        console.error(`Erro ao copiar ${obj.Key}:`, error.message);
        errorCount++;
      }
    }

    // Resumo final
    console.log('\n=== RESUMO DA OPERAÇÃO ===');
    console.log(`Total de objetos: ${sourceObjects.Contents.length}`);
    console.log(`Copiados: ${copiedCount}`);
    console.log(`Pulados (já existentes): ${skippedCount}`);
    console.log(`Erros: ${errorCount}`);

    if (DRY_RUN) {
      console.log('\nEste foi apenas um modo de simulação. Para realizar a cópia real, defina DRY_RUN como false.');
    }

  } catch (error) {
    console.error('Erro durante a cópia de objetos:', error);
  }
}

// Executar
copyBucketObjects().catch(console.error);


scripts\diagnose-r2.js

// scripts/diagnose-r2-images-v2.js
const { S3Client, ListObjectsV2Command, GetObjectCommand } = require('@aws-sdk/client-s3');
const fs = require('fs');
const path = require('path');
const sharp = require('sharp');
const dotenv = require('dotenv');
const { tmpdir } = require('os');

// Carregar variáveis de ambiente
dotenv.config();

// Criar cliente R2
const s3Client = new S3Client({
  region: process.env.CF_REGION || 'auto',
  endpoint: process.env.CF_ENDPOINT,
  credentials: {
    accessKeyId: process.env.CF_ACCESS_KEY_ID,
    secretAccessKey: process.env.CF_ACCESS_SECRET,
  },
});

// Diretório para salvar imagens temporárias
const TEMP_DIR = path.join(tmpdir(), 'r2-images-diagnose');
if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR, { recursive: true });
}

// Função para obter a URL formatada
function getFormattedUrl(key) {
  if (process.env.CF_PUBLIC_ACCESS_URL) {
    return `${process.env.CF_PUBLIC_ACCESS_URL.replace(/\/$/, '')}/${key}`;
  }
  return `${process.env.CF_ENDPOINT.replace(/\/$/, '')}/${process.env.CF_BUCKET}/${key}`;
}

// Função para verificar se a imagem é transparente
async function isTransparentImage(filePath) {
  try {
    const metadata = await sharp(filePath).metadata();
    // A imagem tem canal alpha e é PNG, WebP ou similar
    return metadata.hasAlpha === true && metadata.channels === 4;
  } catch (error) {
    console.error(`Erro ao analisar imagem ${filePath}: ${error.message}`);
    return false;
  }
}

// Função para verificar imagens em um prefixo específico
async function checkImagesInPrefix(prefix) {
  console.log(`\n=== VERIFICANDO IMAGENS EM ${prefix}/ ===`);

  try {
    // Listar objetos com o prefixo
    const listCommand = new ListObjectsV2Command({
      Bucket: process.env.CF_BUCKET,
      Prefix: prefix + '/',
      MaxKeys: 20 // Limitar para amostragem
    });

    const listResult = await s3Client.send(listCommand);

    if (!listResult.Contents || listResult.Contents.length === 0) {
      console.log(`Nenhuma imagem encontrada no prefixo ${prefix}/`);
      return { total: 0, transparent: 0, errors: 0 };
    }

    console.log(`Encontradas ${listResult.Contents.length} imagens no prefixo ${prefix}/`);

    // Filtrar apenas arquivos de imagem
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
    const imageObjects = listResult.Contents.filter(obj => {
      const ext = path.extname(obj.Key).toLowerCase();
      return imageExtensions.includes(ext);
    });

    console.log(`Total de arquivos de imagem: ${imageObjects.length}`);

    // Analisar uma amostra de imagens (limitando para não sobrecarregar)
    const sampleSize = Math.min(imageObjects.length, 5); // Limitar a 5 imagens por prefixo
    const imageSample = imageObjects.slice(0, sampleSize);

    console.log(`\nAnalisando amostra de ${sampleSize} imagens...`);

    let transparentCount = 0;
    let errorCount = 0;

    for (let i = 0; i < imageSample.length; i++) {
      const imageObj = imageSample[i];
      console.log(`\nImagem ${i+1}/${sampleSize}: ${imageObj.Key}`);

      try {
        // Obter o objeto do R2
        const getCommand = new GetObjectCommand({
          Bucket: process.env.CF_BUCKET,
          Key: imageObj.Key,
        });

        const getResult = await s3Client.send(getCommand);

        // Salvar temporariamente para análise
        const tempFilePath = path.join(TEMP_DIR, path.basename(imageObj.Key));
        const fileStream = fs.createWriteStream(tempFilePath);

        await new Promise((resolve, reject) => {
          getResult.Body.pipe(fileStream)
            .on('finish', () => {
              resolve();
            })
            .on('error', (err) => {
              reject(err);
            });
        });

        // Verificar se a imagem tem transparência
        const transparent = await isTransparentImage(tempFilePath);

        // Obter informações da imagem
        const metadata = await sharp(tempFilePath).metadata();

        console.log(`  URL: ${getFormattedUrl(imageObj.Key)}`);
        console.log(`  Formato: ${metadata.format}`);
        console.log(`  Dimensões: ${metadata.width}x${metadata.height}`);
        console.log(`  Canais: ${metadata.channels}`);
        console.log(`  Tem transparência: ${transparent ? 'Sim' : 'Não'}`);

        if (transparent) {
          transparentCount++;
        }

        // Limpar arquivo temporário
        fs.unlinkSync(tempFilePath);
      } catch (error) {
        console.error(`  Erro ao analisar imagem: ${error.message}`);
        errorCount++;
      }
    }

    return {
      total: sampleSize,
      transparent: transparentCount,
      errors: errorCount
    };

  } catch (error) {
    console.error(`Erro ao analisar prefixo ${prefix}/: ${error.message}`);
    return { total: 0, transparent: 0, errors: 0 };
  }
}

// Função principal de diagnóstico
async function diagnoseR2Images() {
  console.log('=== DIAGNÓSTICO DE IMAGENS NO R2 ===');
  console.log(`Bucket: ${process.env.CF_BUCKET}`);
  console.log(`Endpoint: ${process.env.CF_ENDPOINT}`);
  console.log(`URL pública: ${process.env.CF_PUBLIC_ACCESS_URL || 'Não configurada'}`);

  if (!process.env.CF_BUCKET || !process.env.CF_ENDPOINT) {
    console.error('Erro: Configuração R2 incompleta. Verifique as variáveis de ambiente.');
    return;
  }

  try {
    // Primeiro, listar todos os objetos para descobrir prefixos
    console.log('\nDescobrir prefixos disponíveis...');
    const listCommand = new ListObjectsV2Command({
      Bucket: process.env.CF_BUCKET,
      MaxKeys: 1000
    });

    const listResult = await s3Client.send(listCommand);

    if (!listResult.Contents || listResult.Contents.length === 0) {
      console.log('Nenhum objeto encontrado no bucket.');
      return;
    }

    // Extrair prefixos únicos (primeiro nível)
    const prefixes = new Set();
    listResult.Contents.forEach(obj => {
      const firstLevel = obj.Key.split('/')[0];
      if (firstLevel) {
        prefixes.add(firstLevel);
      }
    });

    console.log(`Prefixos encontrados: ${Array.from(prefixes).join(', ')}`);

    // Analisar imagens em cada prefixo
    let totalStats = { total: 0, transparent: 0, errors: 0 };

    for (const prefix of prefixes) {
      const stats = await checkImagesInPrefix(prefix);
      totalStats.total += stats.total;
      totalStats.transparent += stats.transparent;
      totalStats.errors += stats.errors;
    }

    // Resumo geral
    console.log('\n=== RESUMO GERAL DA ANÁLISE ===');
    console.log(`Total de imagens analisadas: ${totalStats.total}`);
    console.log(`Imagens com transparência: ${totalStats.transparent} (${(totalStats.transparent/totalStats.total*100 || 0).toFixed(1)}%)`);
    console.log(`Erros durante a análise: ${totalStats.errors} (${(totalStats.errors/totalStats.total*100 || 0).toFixed(1)}%)`);

    // Limpar diretório temporário
    fs.rmSync(TEMP_DIR, { recursive: true, force: true });

  } catch (error) {
    console.error('Erro durante o diagnóstico:', error.message);
  }
}

// Executar diagnóstico
diagnoseR2Images().catch(error => {
  console.error('Erro fatal durante o diagnóstico:', error);
});


scripts\diagnose-upload.js

const fs = require('fs');
const path = require('path');
require('dotenv').config();

console.log('=== DIAGNÓSTICO DE UPLOAD R2 ===');
console.log('\nVariáveis de ambiente:');
console.log('R2_ACCESS_KEY:', process.env.R2_ACCESS_KEY ? '✓ Configurado' : '✗ Não configurado');
console.log('R2_SECRET_KEY:', process.env.R2_SECRET_KEY ? '✓ Configurado' : '✗ Não configurado');
console.log('R2_ENDPOINT:', process.env.R2_ENDPOINT);
console.log('R2_BUCKET:', process.env.R2_BUCKET);
console.log('R2_PUBLIC_URL:', process.env.R2_PUBLIC_URL);
console.log('R2_REGION:', process.env.R2_REGION);

console.log('\nVerificando arquivos de configuração:');

// Verificar plugins.js
try {
  const pluginsPath = path.join(process.cwd(), 'config', 'plugins.js');
  if (fs.existsSync(pluginsPath)) {
    console.log('✓ plugins.js encontrado');
    const content = fs.readFileSync(pluginsPath, 'utf8');
    console.log('  Provider configurado:', content.includes('@strapi/provider-upload-aws-s3') ? 'aws-s3' : 'outro');
    console.log('  Configuração S3 em formato correto:', content.includes('s3Options:') ? 'Sim' : 'Não');
  } else {
    console.log('✗ plugins.js não encontrado');
  }
} catch (error) {
  console.error('Erro ao verificar plugins.js:', error.message);
}

// Verificar extensões de upload
try {
  const extensionsPath = path.join(process.cwd(), 'src', 'extensions', 'upload');
  if (fs.existsSync(extensionsPath)) {
    console.log('✓ Extensões de upload encontradas');

    const serverFile = path.join(extensionsPath, 'strapi-server.js');
    if (fs.existsSync(serverFile)) {
      console.log('  ✓ strapi-server.js encontrado');
      const content = fs.readFileSync(serverFile, 'utf8');
      console.log('    Sobrescreve método de upload:', content.includes('plugin.services.upload.upload') ? 'Sim' : 'Não');
    } else {
      console.log('  ✗ strapi-server.js não encontrado');
    }
  } else {
    console.log('✗ Pasta de extensões de upload não encontrada');
  }
} catch (error) {
  console.error('Erro ao verificar extensões:', error.message);
}

// Verificar middlewares.js
try {
  const middlewaresPath = path.join(process.cwd(), 'config', 'middlewares.js');
  if (fs.existsSync(middlewaresPath)) {
    console.log('✓ middlewares.js encontrado');
    const content = fs.readFileSync(middlewaresPath, 'utf8');
    console.log('  Configuração de cors:', content.includes('strapi::cors') ? 'Sim' : 'Não');
    console.log('  Configuração de body parser:', content.includes('strapi::body') ? 'Sim' : 'Não');
  } else {
    console.log('✗ middlewares.js não encontrado');
  }
} catch (error) {
  console.error('Erro ao verificar middlewares.js:', error.message);
}

console.log('\nVerificando banco de dados:');
try {
  const dbPath = process.env.DATABASE_FILENAME || '/mnt/data/softmeat-db/data.db';
  if (fs.existsSync(dbPath)) {
    console.log(`✓ Banco de dados SQLite encontrado: ${dbPath}`);
    const stats = fs.statSync(dbPath);
    console.log(`  Tamanho: ${(stats.size / (1024 * 1024)).toFixed(2)} MB`);
    console.log(`  Última modificação: ${stats.mtime}`);
  } else {
    console.log(`✗ Banco de dados SQLite não encontrado: ${dbPath}`);
  }
} catch (error) {
  console.error('Erro ao verificar banco de dados:', error.message);
}

console.log('\nResultado do diagnóstico:');
console.log('1. Executar: npm install @strapi/provider-upload-aws-s3');
console.log('2. Verificar permissões do diretório /mnt/data/softmeat-db/');
console.log('3. Reiniciar o servidor: npm run start');


scripts\fix-r2-urls.js

// scripts/fix-r2-urls-improved.js
const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Cores para console
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

async function fixImageUrls(strapi) {
  console.log(`${colors.magenta}=== CORREÇÃO AVANÇADA DE URLs DE IMAGENS ===\n${colors.reset}`);

  // Verificar configurações
  console.log(`${colors.blue}Verificando configurações R2:${colors.reset}`);
  const r2Config = {
    publicUrl: process.env.CF_PUBLIC_ACCESS_URL,
    endpoint: process.env.CF_ENDPOINT,
    bucket: process.env.CF_BUCKET,
    legacyUrl: process.env.R2_CUSTOM_DOMAIN,
  };

  // Validar configurações
  for (const [key, value] of Object.entries(r2Config)) {
    if (value) {
      console.log(`  ✅ ${key}: ${value}`);
    } else {
      console.log(`  ${colors.yellow}⚠️ ${key}: Não configurado${colors.reset}`);
    }
  }

  if (!r2Config.publicUrl) {
    console.error(`${colors.red}Erro: CF_PUBLIC_ACCESS_URL não está configurado, é necessário para corrigir URLs.${colors.reset}`);
    return;
  }

  try {
    // Buscar todos os arquivos no banco de dados
    console.log(`\n${colors.blue}Buscando arquivos no banco de dados...${colors.reset}`);
    const files = await strapi.db.query('plugin::upload.file').findMany({});

    console.log(`Encontrados ${files.length} arquivos no total\n`);

    // Agrupar arquivos por tipo MIME
    const filesByType = {};
    for (const file of files) {
      const type = file.mime ? (file.mime.split('/')[0] || 'other') : 'unknown';
      if (!filesByType[type]) filesByType[type] = [];
      filesByType[type].push(file);
    }

    console.log(`${colors.blue}Distribuição de arquivos por tipo:${colors.reset}`);
    for (const [type, typeFiles] of Object.entries(filesByType)) {
      console.log(`  ${type}: ${typeFiles.length} arquivos`);
    }

    // Extrator de domínio
    const extractDomain = (url) => {
      if (!url) return '';
      try {
        return new URL(url).hostname;
      } catch (error) {
        return '';
      }
    };

    // Formatador de URL
    const formatFileUrl = (url) => {
      if (!url) return { formatted: false, url };

      try {
        // Verificar se a URL já usa o domínio correto
        const publicUrlDomain = extractDomain(r2Config.publicUrl);
        const currentDomain = extractDomain(url);

        if (currentDomain === publicUrlDomain) {
          return { formatted: false, url }; // Já está usando o domínio correto
        }

        // URL nula ou inválida
        if (!url || !url.includes('://')) {
          return { formatted: false, url };
        }

        // Se for URL externa (não R2 nem Cloudflare)
        if (!url.includes('cloudflarestorage.com') &&
            !url.includes(r2Config.endpoint) &&
            !url.includes('softmeat.com.br')) {
          return { formatted: false, url };
        }

        // Extrair caminho relativo
        const urlObj = new URL(url);
        let relativePath = urlObj.pathname;

        // Remover bucket se presente
        if (r2Config.bucket && relativePath.includes(r2Config.bucket)) {
          const bucketIndex = relativePath.indexOf(r2Config.bucket);
          relativePath = relativePath.substring(bucketIndex + r2Config.bucket.length);
        }

        // Remover barra inicial
        while (relativePath.startsWith('/')) {
          relativePath = relativePath.substring(1);
        }

        // Formar nova URL
        const formattedPublicDomain = r2Config.publicUrl.endsWith('/')
          ? r2Config.publicUrl.slice(0, -1)
          : r2Config.publicUrl;

        const newUrl = `${formattedPublicDomain}/${relativePath}`;

        return { formatted: true, url: newUrl };
      } catch (error) {
        console.error(`Erro ao formatar URL ${url}: ${error.message}`);
        return { formatted: false, url };
      }
    };

    // Agrupar arquivos por fonte de URL
    const urlSources = {};
    for (const file of files) {
      if (!file.url) continue;

      const domain = extractDomain(file.url);
      if (!urlSources[domain]) urlSources[domain] = [];
      urlSources[domain].push(file);
    }

    console.log(`\n${colors.blue}Origens de URLs encontradas:${colors.reset}`);
    for (const [domain, domainFiles] of Object.entries(urlSources)) {
      console.log(`  ${domain}: ${domainFiles.length} arquivos`);
    }

    // Começar correção de URLs
    console.log(`\n${colors.blue}Iniciando correção de URLs...${colors.reset}`);

    let updatedCount = 0;
    let errorCount = 0;
    let skippedCount = 0;

    for (const file of files) {
      if (!file.url) {
        console.log(`${colors.yellow}⚠️ Arquivo ${file.id} não tem URL${colors.reset}`);
        skippedCount++;
        continue;
      }

      const { formatted, url: newUrl } = formatFileUrl(file.url);

      if (formatted) {
        try {
          // Verificar se a URL realmente mudou
          if (file.url !== newUrl) {
            // Atualizar URL no banco de dados
            await strapi.db.query('plugin::upload.file').update({
              where: { id: file.id },
              data: { url: newUrl }
            });

            updatedCount++;
            console.log(`✅ [${updatedCount}] URL atualizada: ${file.name}`);
            console.log(`   De: ${file.url}`);
            console.log(`   Para: ${newUrl}`);
          } else {
            skippedCount++;
          }
        } catch (error) {
          console.error(`${colors.red}❌ Erro ao atualizar arquivo ${file.id}: ${error.message}${colors.reset}`);
          errorCount++;
        }
      } else {
        skippedCount++;
      }
    }

    // Resumo final
    console.log(`\n${colors.green}=== RESUMO DA CORREÇÃO DE URLs ===${colors.reset}`);
    console.log(`✅ Total de URLs corrigidas: ${updatedCount}`);
    console.log(`⏩ URLs ignoradas (já corretas ou externas): ${skippedCount}`);
    console.log(`❌ Erros durante a correção: ${errorCount}`);

    if (updatedCount > 0) {
      console.log(`\n${colors.green}As URLs foram atualizadas com sucesso para usar o domínio: ${r2Config.publicUrl}${colors.reset}`);
    } else if (errorCount === 0) {
      console.log(`\n${colors.green}Todas as URLs já estão usando o domínio correto.${colors.reset}`);
    } else {
      console.log(`\n${colors.yellow}A correção de URLs encontrou problemas. Verifique os logs acima.${colors.reset}`);
    }

  } catch (error) {
    console.error(`${colors.red}Erro fatal ao corrigir URLs: ${error.message}${colors.reset}`);
    console.error(error.stack);
  }
}

module.exports = { fixImageUrls };

// Se o script for executado diretamente
if (require.main === module) {
  console.log('Este script deve ser executado através do Strapi:');
  console.log('NODE_ENV=production node -e "require(\'./scripts/fix-r2-urls-improved.js\').fixImageUrls(strapi)"');
}


scripts\list-all-r2-objects.js

// scripts/list-all-r2-objects.js
const { S3Client, ListObjectsV2Command } = require('@aws-sdk/client-s3');
require('dotenv').config();

async function listAllObjects() {
  console.log('=== LISTAGEM COMPLETA DE OBJETOS NO R2 ===');
  console.log(`Bucket: ${process.env.CF_BUCKET}`);
  console.log(`Endpoint: ${process.env.CF_ENDPOINT}`);
  console.log(`URL pública: ${process.env.CF_PUBLIC_ACCESS_URL || 'Não configurada'}`);

  // Criar cliente R2
  const s3Client = new S3Client({
    region: process.env.CF_REGION || 'auto',
    endpoint: process.env.CF_ENDPOINT,
    credentials: {
      accessKeyId: process.env.CF_ACCESS_KEY_ID,
      secretAccessKey: process.env.CF_ACCESS_SECRET,
    },
  });

  try {
    // Listar todos os objetos (sem prefixo específico)
    const command = new ListObjectsV2Command({
      Bucket: process.env.CF_BUCKET,
      MaxKeys: 100
    });

    const response = await s3Client.send(command);

    console.log(`\nTotal de objetos encontrados: ${response.Contents?.length || 0}`);

    if (response.Contents && response.Contents.length > 0) {
      // Agrupar por prefixo para entender a estrutura
      const prefixes = {};

      response.Contents.forEach(obj => {
        // Extrair o primeiro nível do caminho
        const firstLevel = obj.Key.split('/')[0];
        if (!prefixes[firstLevel]) {
          prefixes[firstLevel] = {
            count: 0,
            size: 0,
            examples: []
          };
        }

        prefixes[firstLevel].count++;
        prefixes[firstLevel].size += obj.Size;

        // Guardar alguns exemplos para cada prefixo
        if (prefixes[firstLevel].examples.length < 3) {
          prefixes[firstLevel].examples.push(obj.Key);
        }
      });

      // Mostrar resumo de prefixos
      console.log('\nEstrutura de diretórios:');
      Object.entries(prefixes).forEach(([prefix, info]) => {
        console.log(`- ${prefix}/: ${info.count} objetos (${(info.size / 1024 / 1024).toFixed(2)} MB)`);

        // Mostrar alguns exemplos
        console.log('  Exemplos:');
        info.examples.forEach(example => {
          const url = `${process.env.CF_PUBLIC_ACCESS_URL}/${example}`;
          console.log(`  - ${example}`);
          console.log(`    URL: ${url}`);
        });
      });
    }
  } catch (error) {
    console.error('Erro ao listar objetos:', error);
  }
}

listAllObjects();


scripts\sync-env-vars.js

// scripts/sync-env-vars.js
const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

// Carregar variáveis do ambiente atual
dotenv.config();

// Definir mapeamentos R2 -> CF
const mappings = [
  { from: 'R2_ACCESS_KEY', to: 'CF_ACCESS_KEY_ID' },
  { from: 'R2_SECRET_KEY', to: 'CF_ACCESS_SECRET' },
  { from: 'R2_ENDPOINT', to: 'CF_ENDPOINT' },
  { from: 'R2_BUCKET', to: 'CF_BUCKET' },
  { from: 'R2_REGION', to: 'CF_REGION' },
  { from: 'R2_CUSTOM_DOMAIN', to: 'CF_PUBLIC_ACCESS_URL' }
];

// Criar objeto com novos valores
const newVars = {};
let hasChanges = false;

// Mapear valores existentes
mappings.forEach(({ from, to }) => {
  if (process.env[from] && !process.env[to]) {
    newVars[to] = process.env[from];
    hasChanges = true;
    console.log(`Mapeando ${from} para ${to}: ${process.env[from]}`);
  }
});

if (!hasChanges) {
  console.log('Todas as variáveis já estão configuradas corretamente');
  process.exit(0);
}

// Determinar se estamos em produção ou desenvolvimento
const isProduction = process.env.NODE_ENV === 'production';

if (isProduction) {
  // Em produção, apenas mostrar comandos para definir variáveis
  console.log('\nEm ambiente de produção, use os seguintes comandos:');

  Object.entries(newVars).forEach(([key, value]) => {
    // Mostrar comando para Railway, Heroku ou similar
    console.log(`railway variables set ${key}="${value}"`);
    // Ou para ambiente genérico
    console.log(`export ${key}="${value}"`);
  });
} else {
  // Em desenvolvimento, atualizar arquivo .env
  const envPath = path.join(process.cwd(), '.env');

  if (!fs.existsSync(envPath)) {
    console.error('Arquivo .env não encontrado');
    process.exit(1);
  }

  let envContent = fs.readFileSync(envPath, 'utf8');

  // Adicionar novas variáveis
  envContent += '\n\n# Variáveis mapeadas automaticamente\n';
  Object.entries(newVars).forEach(([key, value]) => {
    envContent += `${key}=${value}\n`;
  });

  // Salvar o arquivo atualizado
  fs.writeFileSync(envPath, envContent);
  console.log('\nArquivo .env atualizado com sucesso!');
}


scripts\test-r2-connection.js

// test-r2-connection.js
const { S3Client, ListObjectsV2Command } = require('@aws-sdk/client-s3');
const dotenv = require('dotenv');
const path = require('path');

// Carregar variáveis de ambiente
dotenv.config({ path: path.resolve(__dirname, '../.env') });

// Verificar se as variáveis foram carregadas
console.log('Variáveis carregadas:');
console.log('R2_ACCESS_KEY existe:', !!process.env.R2_ACCESS_KEY);
console.log('R2_SECRET_KEY existe:', !!process.env.R2_SECRET_KEY);
console.log('R2_ENDPOINT:', process.env.R2_ENDPOINT);
console.log('R2_BUCKET:', process.env.R2_BUCKET);
console.log('R2_REGION:', process.env.R2_REGION || 'auto');
console.log('R2_CUSTOM_DOMAIN:', process.env.R2_CUSTOM_DOMAIN);

// Verificar se as variáveis essenciais estão presentes
if (!process.env.R2_ACCESS_KEY || !process.env.R2_SECRET_KEY || !process.env.R2_ENDPOINT || !process.env.R2_BUCKET) {
 console.error('Erro: Variáveis de ambiente R2 não encontradas!');
 console.error('Por favor, verifique se o arquivo .env contém as configurações do R2.');
 process.exit(1);
}

// Configurar o cliente R2
const r2Client = new S3Client({
 region: process.env.R2_REGION || 'auto',
 endpoint: process.env.R2_ENDPOINT,
 credentials: {
   accessKeyId: process.env.R2_ACCESS_KEY,
   secretAccessKey: process.env.R2_SECRET_KEY,
 },
});

async function testConnection() {
 try {
   console.log('\nTentando conectar ao R2...');

   // Listar objetos no bucket
   const command = new ListObjectsV2Command({
     Bucket: process.env.R2_BUCKET,
     MaxKeys: 10, // Limitando a 10 objetos para teste
   });

   const response = await r2Client.send(command);

   console.log(`\nConexão com R2 bem-sucedida!`);
   console.log(`Encontrados ${response.Contents?.length || 0} objetos:`);

   // Mostrar alguns objetos
   (response.Contents || []).forEach((obj, index) => {
     console.log(`${index + 1}. ${obj.Key} (${obj.Size} bytes)`);

     // Construir URL usando o domínio personalizado
     const customUrl = `${process.env.R2_CUSTOM_DOMAIN}/${obj.Key}`;
     console.log(`   URL custom: ${customUrl}`);

     // Construir URL direta do R2
     const directUrl = `${process.env.R2_ENDPOINT}/${process.env.R2_BUCKET}/${obj.Key}`;
     console.log(`   URL direta: ${directUrl}`);
   });

 } catch (error) {
   console.error('Erro ao conectar com R2:', error);
 }
}

testConnection();


scripts\test-r2-provider.js

// scripts/test-r2-provider.js
// Script para testar a configuração do provider R2
require('dotenv').config();
const fs = require('fs');
const path = require('path');
const { S3Client, PutObjectCommand, GetObjectCommand, ListObjectsV2Command } = require('@aws-sdk/client-s3');

// Cores para console
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

// Configurações
const testFilePath = path.join(__dirname, 'test-file.txt');
const testFileKey = `test/provider-test-${Date.now()}.txt`;

// Criar o arquivo de teste
fs.writeFileSync(testFilePath, `Teste de upload para R2 - ${new Date().toISOString()}`);

// Configurar cliente R2
const s3Client = new S3Client({
  region: 'auto',
  endpoint: process.env.CF_ENDPOINT,
  credentials: {
    accessKeyId: process.env.CF_ACCESS_KEY_ID,
    secretAccessKey: process.env.CF_ACCESS_SECRET,
  },
});

// Funções auxiliares
function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

// Teste de upload
async function testUpload() {
  log('\n=== TESTE DO PROVIDER STRAPI-PROVIDER-CLOUDFLARE-R2 ===', colors.magenta);

  // Verificar variáveis de ambiente
  log('\n[1] Verificando variáveis de ambiente:', colors.blue);
  const requiredVars = ['CF_ACCESS_KEY_ID', 'CF_ACCESS_SECRET', 'CF_ENDPOINT', 'CF_BUCKET', 'CF_PUBLIC_ACCESS_URL'];

  let missingVars = [];
  for (const varName of requiredVars) {
    if (!process.env[varName]) {
      log(`  ❌ ${varName}: Não encontrada`, colors.red);
      missingVars.push(varName);
    } else {
      log(`  ✅ ${varName}: Configurada`);
    }
  }

  if (missingVars.length > 0) {
    log(`\n❌ As seguintes variáveis não estão configuradas: ${missingVars.join(', ')}`, colors.red);
    log('Por favor, configure-as no arquivo .env e tente novamente');
    return;
  }

  // Testar conexão e listagem
  log('\n[2] Testando conexão e listagem de objetos:', colors.blue);
  try {
    const listCommand = new ListObjectsV2Command({
      Bucket: process.env.CF_BUCKET,
      MaxKeys: 5
    });

    const listResponse = await s3Client.send(listCommand);
    log(`  ✅ Conexão estabelecida com sucesso`);
    log(`  ✅ Encontrados ${listResponse.Contents?.length || 0} objetos`);

    if (listResponse.Contents && listResponse.Contents.length > 0) {
      log(`\n  Exemplos de objetos:`);
      listResponse.Contents.slice(0, 3).forEach((obj, i) => {
        log(`  ${i+1}. ${obj.Key} (${obj.Size} bytes)`);

        // Construir URL direta e pública
        const directUrl = `${process.env.CF_ENDPOINT}/${process.env.CF_BUCKET}/${obj.Key}`;
        const publicUrl = `${process.env.CF_PUBLIC_ACCESS_URL}/${obj.Key}`;

        log(`     URL direta: ${directUrl}`);
        log(`     URL pública: ${publicUrl}`);
      });
    }
  } catch (error) {
    log(`  ❌ Erro ao conectar ao R2: ${error.message}`, colors.red);
    return;
  }

  // Testar upload
  log('\n[3] Testando upload de arquivo:', colors.blue);
  try {
    const fileContent = fs.readFileSync(testFilePath);

    const uploadCommand = new PutObjectCommand({
      Bucket: process.env.CF_BUCKET,
      Key: testFileKey,
      Body: fileContent,
      ContentType: 'text/plain',
      ACL: 'public-read'
    });

    await s3Client.send(uploadCommand);
    log(`  ✅ Arquivo enviado com sucesso`);

    // Construir URLs
    const directUrl = `${process.env.CF_ENDPOINT}/${process.env.CF_BUCKET}/${testFileKey}`;
    const publicUrl = `${process.env.CF_PUBLIC_ACCESS_URL}/${testFileKey}`;

    log(`  URL direta: ${directUrl}`);
    log(`  URL pública: ${publicUrl}`);

    // Testar download
    log('\n[4] Testando download do arquivo:', colors.blue);
    const getCommand = new GetObjectCommand({
      Bucket: process.env.CF_BUCKET,
      Key: testFileKey
    });

    const getResponse = await s3Client.send(getCommand);
    log(`  ✅ Arquivo recuperado com sucesso`);
    log(`  Content-Type: ${getResponse.ContentType}`);
    log(`  Content-Length: ${getResponse.ContentLength} bytes`);

    // Limpar
    fs.unlinkSync(testFilePath);
    log(`\n✅ Teste concluído com sucesso!`, colors.green);
    log(`O arquivo de teste foi enviado para: ${testFileKey}`);
    log(`\nPróximos passos:`);
    log(`1. Verifique se pode acessar a URL pública: ${publicUrl}`);
    log(`2. Configure o plugin no Strapi conforme documentação`);
    log(`3. Reinicie o servidor Strapi e teste o upload pelo painel admin`);
  } catch (error) {
    log(`  ❌ Erro durante o teste: ${error.message}`, colors.red);
  }
}

// Executar o teste
testUpload();


scripts\test-r2-reference-endpoint.js

// scripts/test-r2-reference-endpoint.js
const axios = require('axios');
const dotenv = require('dotenv');
dotenv.config();

// Configuração
const API_URL = process.env.PUBLIC_URL || 'http://localhost:1337';
const API_TOKEN = process.env.API_TOKEN; // Adicione seu token de API ao .env

async function testMediaReference() {
  console.log('=== TESTE DE REFERENCIAMENTO DE MÍDIA ===');

  // URL de teste
  const testUrl = 'https://storage.softmeat.com.br/produtos/exemplo-teste.jpg';

  try {
    console.log(`Tentando referenciar: ${testUrl}`);

    const response = await axios.post(
      `${API_URL}/api/media/reference`,
      {
        url: testUrl,
        name: 'Exemplo de Teste',
        caption: 'Imagem referenciada via API',
        alternativeText: 'Imagem de teste'
      },
      {
        headers: {
          'Authorization': `Bearer ${API_TOKEN}`,
          'Content-Type': 'application/json'
        }
      }
    );

    console.log('✅ Sucesso!');
    console.log('Resposta:', JSON.stringify(response.data, null, 2));

  } catch (error) {
    console.error('❌ Erro:');
    if (error.response) {
      console.error('Status:', error.response.status);
      console.error('Dados:', JSON.stringify(error.response.data, null, 2));
    } else {
      console.error(error.message);
    }
  }
}

testMediaReference();


scripts\test-r2-reference.js

// scripts/test-r2-reference.js
const dotenv = require('dotenv');
dotenv.config();

async function testR2Reference(strapi) {
  console.log('=== TESTE DE REFERENCIAMENTO DE IMAGENS R2 ===');

  try {
    // 1. Simular uma URL do R2
    const r2Url = 'https://images.softmeat.com.br/produtos/bacon-12345.jpg';

    // 2. Criar um objeto de arquivo simulado
    const fileData = {
      name: 'teste-referencia.jpg',
      url: r2Url,
      mime: 'image/jpeg',
      size: 10240,
      ext: '.jpg',
    };

    console.log('Testando referência de URL R2:', r2Url);

    // 3. Simular o upload usando a biblioteca
    const uploadService = strapi.plugins.upload.services.upload;
    const result = await uploadService.upload({
      data: {
        fileInfo: fileData
      },
      files: {}
    });

    console.log('Resultado do teste:');
    console.log(' - URL: ', result?.url);
    console.log(' - Provider: ', result?.provider);
    console.log(' - Tamanho: ', result?.size);
    console.log(' - isExternalUrl: ', result?.isExternalUrl);

    if (result?.url === r2Url) {
      console.log('✅ SUCESSO! A URL original foi preservada');
    } else {
      console.log('❌ FALHA! A URL foi modificada');
    }

  } catch (error) {
    console.error('Erro durante o teste:', error);
  }
}

// Exportar para uso com strapi
module.exports = { testR2Reference };

// Se executado diretamente
if (require.main === module) {
  console.log('Execute este script através do Strapi:');
  console.log('NODE_ENV=development node -e "require(\'./scripts/test-r2-reference.js\').testR2Reference(strapi)"');
}


scripts\test-r2-simple.js

const { S3 } = require('aws-sdk');
require('dotenv').config();

async function testR2() {
  console.log('Testando conexão com R2...');

  const s3 = new S3({
    accessKeyId: process.env.R2_ACCESS_KEY,
    secretAccessKey: process.env.R2_SECRET_KEY,
    endpoint: process.env.R2_ENDPOINT,
    s3ForcePathStyle: true,
    signatureVersion: 'v4',
    region: process.env.R2_REGION || 'auto'
  });

  try {
    const result = await s3.listObjects({ Bucket: process.env.R2_BUCKET }).promise();
    console.log('Conexão com R2 bem-sucedida!');
    console.log(`Objetos encontrados: ${result.Contents.length}`);

    // Testar alguns objetos
    if (result.Contents.length > 0) {
      console.log('\nExemplos de objetos:');
      result.Contents.slice(0, 3).forEach(obj => {
        console.log(`- ${obj.Key} (${obj.Size} bytes)`);
        console.log(`  URL: ${process.env.R2_PUBLIC_URL}/${obj.Key}`);
      });
    }
  } catch (error) {
    console.error('Erro ao conectar com R2:', error);
  }
}

testR2();


scripts\test-r2-upload.js

// scripts/test-r2-upload.js - versão atualizada
const { S3Client, ListObjectsV2Command, PutObjectCommand } = require('@aws-sdk/client-s3');
const fs = require('fs');
const path = require('path');

// Carregar variáveis de ambiente
require('dotenv').config();

// Verificar variáveis configuradas
console.log('=== TESTE DE CONEXÃO R2 ===');
console.log('CF_ACCESS_KEY_ID existe:', !!process.env.CF_ACCESS_KEY_ID);
console.log('CF_ACCESS_SECRET existe:', !!process.env.CF_ACCESS_SECRET);
console.log('CF_ENDPOINT:', process.env.CF_ENDPOINT);
console.log('CF_BUCKET:', process.env.CF_BUCKET);
console.log('CF_REGION:', process.env.CF_REGION || 'auto');
console.log('CF_PUBLIC_ACCESS_URL:', process.env.CF_PUBLIC_ACCESS_URL);

// Configurar cliente R2
const r2Client = new S3Client({
  region: process.env.CF_REGION || 'auto',
  endpoint: process.env.CF_ENDPOINT,
  credentials: {
    accessKeyId: process.env.CF_ACCESS_KEY_ID,
    secretAccessKey: process.env.CF_ACCESS_SECRET,
  },
});

// Função para formatar URL R2
const formatR2Url = (path) => {
  if (!path) return '';
  const cleanPath = path.startsWith('/') ? path.substring(1) : path;

  if (process.env.CF_PUBLIC_ACCESS_URL) {
    const domain = process.env.CF_PUBLIC_ACCESS_URL.endsWith('/')
      ? process.env.CF_PUBLIC_ACCESS_URL.slice(0, -1)
      : process.env.CF_PUBLIC_ACCESS_URL;
    return `${domain}/${cleanPath}`;
  }

  const endpoint = process.env.CF_ENDPOINT;
  const bucket = process.env.CF_BUCKET;

  if (!endpoint || !bucket) {
    console.error('Erro: CF_ENDPOINT ou CF_BUCKET não definidos!');
    return '';
  }

  const cleanEndpoint = endpoint.endsWith('/')
    ? endpoint.slice(0, -1)
    : endpoint;

  return `${cleanEndpoint}/${bucket}/${cleanPath}`;
};

// Função para testar listagem de arquivos
async function testListFiles() {
  try {
    console.log('\nTentando listar arquivos no bucket R2...');

    const command = new ListObjectsV2Command({
      Bucket: process.env.CF_BUCKET,
      MaxKeys: 5
    });

    const response = await r2Client.send(command);
    console.log(`✅ Sucesso! Encontrados ${response.Contents?.length || 0} arquivos\n`);

    // Mostrar alguns arquivos
    if (response.Contents && response.Contents.length > 0) {
      console.log('Exemplos de arquivos:');
      response.Contents.slice(0, 5).forEach((file, index) => {
        const url = formatR2Url(file.Key);
        console.log(`${index + 1}. ${file.Key} -> ${url}`);
      });
    }

    return true;
  } catch (error) {
    console.error('❌ Erro ao listar arquivos:', error.message);
    return false;
  }
}

// Função para testar upload de arquivo
async function testUpload() {
  try {
    console.log('\nTentando fazer upload de arquivo de teste para R2...');

    // Criar arquivo de teste
    const testFile = path.join(__dirname, 'test-file.txt');
    fs.writeFileSync(testFile, `Arquivo de teste gerado em ${new Date().toISOString()}`);

    // Configurar comando de upload
    const fileStream = fs.createReadStream(testFile);
    const fileKey = `test/test-upload-${Date.now()}.txt`;

    const uploadParams = {
      Bucket: process.env.CF_BUCKET,
      Key: fileKey,
      Body: fileStream,
      ContentType: 'text/plain',
      ACL: 'public-read'
    };

    // Enviar arquivo
    await r2Client.send(new PutObjectCommand(uploadParams));
    console.log('✅ Upload concluído com sucesso');

    // Mostrar URL
    const url = formatR2Url(fileKey);
    console.log(`URL do arquivo: ${url}`);

    // Limpar
    fs.unlinkSync(testFile);
    console.log('Arquivo de teste local removido');

    return true;
  } catch (error) {
    console.error('❌ Erro ao fazer upload:', error.message);
    return false;
  }
}

// Testar formatação de URLs
function testFormatUrls() {
  console.log('\nTeste de formatação de URLs:');

  const testPaths = [
    'images/test/example.jpg',
    '/images/product/photo.png',
    'videos/testimonials/video.mp4'
  ];

  for (const path of testPaths) {
    const url = formatR2Url(path);
    console.log(`${path} -> ${url}`);
  }
}

// Executar testes
async function runTests() {
  console.log('\n=== INICIANDO TESTES R2 ===');

  // Verificar variáveis necessárias
  if (!process.env.CF_ACCESS_KEY_ID || !process.env.CF_ACCESS_SECRET ||
      !process.env.CF_ENDPOINT || !process.env.CF_BUCKET) {
    console.error('❌ Configuração incompleta. Verifique as variáveis de ambiente.');
    return;
  }

  // Testar formatação de URLs
  testFormatUrls();

  // Testar conexão e listagem
  const listSuccess = await testListFiles();

  // Testar upload se listagem for bem-sucedida
  if (listSuccess) {
    await testUpload();
  }

  console.log('\n=== TESTES CONCLUÍDOS ===');
}

// Executar todos os testes
runTests();


scripts\update-env.js

// scripts/update-env.js
// Este script atualiza o arquivo .env com as variáveis necessárias para o Cloudflare R2
const fs = require('fs');
const path = require('path');

const envPath = path.join(process.cwd(), '.env');

// Verificar se o arquivo .env existe
if (!fs.existsSync(envPath)) {
  console.error('\x1b[31mArquivo .env não encontrado. Crie o arquivo primeiro.\x1b[0m');
  process.exit(1);
}

// Ler o conteúdo atual do arquivo .env
let envContent = fs.readFileSync(envPath, 'utf8');

// Verificar quais variáveis já existem
const existingVars = {
  CF_ACCESS_KEY_ID: envContent.includes('CF_ACCESS_KEY_ID='),
  CF_ACCESS_SECRET: envContent.includes('CF_ACCESS_SECRET='),
  CF_ENDPOINT: envContent.includes('CF_ENDPOINT='),
  CF_BUCKET: envContent.includes('CF_BUCKET='),
  CF_PUBLIC_ACCESS_URL: envContent.includes('CF_PUBLIC_ACCESS_URL='),
};

// Ler variáveis R2 existentes para usar como padrão
const r2Vars = {
  R2_ACCESS_KEY: (envContent.match(/R2_ACCESS_KEY=([^\n]*)/)?.[1] || '').trim(),
  R2_SECRET_KEY: (envContent.match(/R2_SECRET_KEY=([^\n]*)/)?.[1] || '').trim(),
  R2_ENDPOINT: (envContent.match(/R2_ENDPOINT=([^\n]*)/)?.[1] || '').trim(),
  R2_BUCKET: (envContent.match(/R2_BUCKET=([^\n]*)/)?.[1] || '').trim(),
  R2_CUSTOM_DOMAIN: (envContent.match(/R2_CUSTOM_DOMAIN=([^\n]*)/)?.[1] || '').trim(),
};

// Preparar novas variáveis
const newVars = [];

if (!existingVars.CF_ACCESS_KEY_ID) {
  newVars.push(`CF_ACCESS_KEY_ID=${r2Vars.R2_ACCESS_KEY}`);
}

if (!existingVars.CF_ACCESS_SECRET) {
  newVars.push(`CF_ACCESS_SECRET=${r2Vars.R2_SECRET_KEY}`);
}

if (!existingVars.CF_ENDPOINT) {
  newVars.push(`CF_ENDPOINT=${r2Vars.R2_ENDPOINT}`);
}

if (!existingVars.CF_BUCKET) {
  newVars.push(`CF_BUCKET=${r2Vars.R2_BUCKET}`);
}

if (!existingVars.CF_PUBLIC_ACCESS_URL) {
  newVars.push(`CF_PUBLIC_ACCESS_URL=${r2Vars.R2_CUSTOM_DOMAIN || 'https://images.softmeat.com.br'}`);
}

// Adicionar as novas variáveis ao arquivo .env
if (newVars.length > 0) {
  envContent += '\n\n# Variáveis Cloudflare R2 para strapi-provider-cloudflare-r2\n';
  envContent += newVars.join('\n');

  // Salvar o arquivo atualizado
  fs.writeFileSync(envPath, envContent);

  console.log('\x1b[32mVariáveis adicionadas ao arquivo .env:\x1b[0m');
  newVars.forEach(v => console.log(`- ${v.split('=')[0]}`));
} else {
  console.log('\x1b[32mTodas as variáveis necessárias já existem no arquivo .env\x1b[0m');
}

console.log('\n\x1b[34mPróximos passos:\x1b[0m');
console.log('1. Verifique se as variáveis têm os valores corretos no arquivo .env');
console.log('2. Instale o provider: npm install strapi-provider-cloudflare-r2');
console.log('3. Reinicie o servidor Strapi: npm run develop');


scripts\upload-original-images-to-r2.js

// scripts/upload-original-images-to-r2.js
const fs = require('fs');
const path = require('path');
const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');
const dotenv = require('dotenv');
const mime = require('mime-types');

// Carregar variáveis de ambiente
dotenv.config();

// Configurar o cliente R2
const r2Client = new S3Client({
  region: process.env.R2_REGION || 'auto',
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY,
    secretAccessKey: process.env.R2_SECRET_KEY,
  },
});

// Diretório base de imagens
const BASE_IMAGE_DIR = path.join(__dirname, '/images');

// Mapeamento de pastas para categorias no R2
const FOLDER_CATEGORY_MAP = {
  'clientes': 'clientes',
  'consultoria': 'consultoria',
  'cursos': 'cursos',
  'index': 'index',
  'institucional': 'institucional',
  'logo': 'logo',
  'produtos': 'produtos',
  'testemunhos': 'testemunhos',
  // Adicione outros mapeamentos conforme necessário
};

// Função para verificar se o arquivo é uma imagem
function isImageFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  return ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'].includes(ext);
}

// Função para determinar o tipo de recurso com base no MIME type
function getResourceType(mimeType) {
  if (mimeType.startsWith('image/')) return 'images';
  if (mimeType.startsWith('video/')) return 'videos';
  if (mimeType.startsWith('audio/')) return 'audios';
  return 'files';
}

// Função para determinar a categoria com base no caminho do arquivo
function getCategory(filePath) {
  const relativePath = path.relative(BASE_IMAGE_DIR, filePath);
  const segments = relativePath.split(path.sep);

  // Obter a primeira pasta do caminho relativo
  const firstFolder = segments[0];

  // Retornar a categoria mapeada ou 'geral' como fallback
  return FOLDER_CATEGORY_MAP[firstFolder] || 'geral';
}

// Função para fazer upload de um arquivo para o R2
async function uploadFileToR2(filePath) {
  try {
    // Ler o arquivo
    const fileContent = fs.readFileSync(filePath);

    // Determinar MIME type
    const mimeType = mime.lookup(filePath) || 'application/octet-stream';

    // Determinar tipo de recurso (images, videos, etc)
    const resourceType = getResourceType(mimeType);

    // Determinar categoria baseado no caminho
    const category = getCategory(filePath);

    // Gerar nome de arquivo (mantendo o nome original)
    const fileName = path.basename(filePath);

    // Criar o path no R2
    const r2Key = `${category}/${fileName}`;

    // Upload para o R2
    const command = new PutObjectCommand({
      Bucket: process.env.R2_BUCKET,
      Key: r2Key,
      Body: fileContent,
      ContentType: mimeType,
      ACL: 'public-read',
      CacheControl: 'public, max-age=31536000, immutable',
    });

    await r2Client.send(command);
    console.log(`Uploaded ${filePath} to ${r2Key}`);
    return r2Key;
  } catch (error) {
    console.error(`Error uploading ${filePath}:`, error);
    throw error;
  }
}

// Função para percorrer diretório recursivamente
async function processDirectory(directory) {
  const items = fs.readdirSync(directory);

  for (const item of items) {
    const itemPath = path.join(directory, item);
    const stats = fs.statSync(itemPath);

    if (stats.isDirectory()) {
      // Se for diretório, processa recursivamente
      await processDirectory(itemPath);
    } else if (stats.isFile() && isImageFile(itemPath)) {
      // Se for arquivo de imagem, faz upload
      await uploadFileToR2(itemPath);
    }
  }
}

// Função principal
async function main() {
  try {
    console.log('Starting upload of original images to R2...');
    await processDirectory(BASE_IMAGE_DIR);
    console.log('Upload completed successfully!');
  } catch (error) {
    console.error('Error during upload process:', error);
    process.exit(1);
  }
}

// Executar o script
main();


scripts\verify-r2-urls.js

const dotenv = require('dotenv');
const { S3Client, ListObjectsV2Command } = require('@aws-sdk/client-s3');

dotenv.config();

// Log de configuração
console.log('=== VERIFICAÇÃO DE CONFIGURAÇÃO R2 ===');
console.log('NODE_ENV:', process.env.NODE_ENV);
console.log('CF_ACCESS_KEY_ID:', process.env.CF_ACCESS_KEY_ID ? '✓ Configurado' : '✗ Não configurado');
console.log('CF_ACCESS_SECRET:', process.env.CF_ACCESS_SECRET ? '✓ Configurado' : '✗ Não configurado');
console.log('CF_ENDPOINT:', process.env.CF_ENDPOINT);
console.log('CF_BUCKET:', process.env.CF_BUCKET);
console.log('CF_PUBLIC_ACCESS_URL:', process.env.CF_PUBLIC_ACCESS_URL);

// Verificar se as credenciais estão configuradas
if (!process.env.CF_ACCESS_KEY_ID || !process.env.CF_ACCESS_SECRET) {
  console.error('Erro: Credenciais R2 não configuradas!');
  process.exit(1);
}

// Função para verificar URLs em um bucket
async function checkBucketUrls(bucketName) {
  console.log(`\n=== Verificando URLs no bucket: ${bucketName} ===`);

  // Configurar cliente R2
  const r2Client = new S3Client({
    region: process.env.CF_REGION || 'auto',
    endpoint: process.env.CF_ENDPOINT,
    credentials: {
      accessKeyId: process.env.CF_ACCESS_KEY_ID,
      secretAccessKey: process.env.CF_ACCESS_SECRET,
    }
  });

  try {
    // Listar objetos no bucket
    const command = new ListObjectsV2Command({
      Bucket: bucketName,
      MaxKeys: 50 // Limitar para não sobrecarregar
    });

    const response = await r2Client.send(command);

    if (!response.Contents || response.Contents.length === 0) {
      console.log(`Nenhum objeto encontrado no bucket ${bucketName}`);
      return;
    }

    console.log(`Encontrados ${response.Contents.length} objetos no bucket ${bucketName}`);

    // Calcular estatísticas de estrutura de pastas
    const prefixes = {};
    response.Contents.forEach(obj => {
      const firstLevel = obj.Key.split('/')[0];
      prefixes[firstLevel] = (prefixes[firstLevel] || 0) + 1;
    });

    console.log('\nEstrutura de pastas:');
    Object.entries(prefixes).forEach(([prefix, count]) => {
      console.log(`- ${prefix}: ${count} objetos`);
    });

    // Verificar URLs públicas
    const publicDomain = process.env.CF_PUBLIC_ACCESS_URL || 'https://images.softmeat.com.br';

    console.log('\nExemplos de URLs:');
    for (let i = 0; i < Math.min(5, response.Contents.length); i++) {
      const obj = response.Contents[i];
      const publicUrl = `${publicDomain}/${obj.Key}`;

      console.log(`\n[${i+1}] Objeto: ${obj.Key}`);
      console.log(`    Tamanho: ${obj.Size} bytes`);
      console.log(`    URL pública: ${publicUrl}`);

      // Verificar a acessibilidade da URL pública
      try {
        const checkResponse = await fetch(publicUrl, { method: 'HEAD' });
        console.log(`    Acessível: ${checkResponse.ok ? '✓ Sim' : '✗ Não'} (Status: ${checkResponse.status})`);
      } catch (error) {
        console.log(`    Acessível: ✗ Não (Error: ${error.message})`);
      }
    }

  } catch (error) {
    console.error(`Erro ao verificar bucket ${bucketName}:`, error.message);
  }
}

// Verificar ambos os buckets
async function main() {
  await checkBucketUrls('softmeat-dev');
  await checkBucketUrls('softmeat-prod');
}

main().catch(console.error);


src\admin\app.example.js

const config = {
  locales: [
    // 'ar',
    // 'fr',
    // 'cs',
    // 'de',
    // 'dk',
    // 'es',
    // 'he',
    // 'id',
    // 'it',
    // 'ja',
    // 'ko',
    // 'ms',
    // 'nl',
    // 'no',
    // 'pl',
    // 'pt-BR',
    // 'pt',
    // 'ru',
    // 'sk',
    // 'sv',
    // 'th',
    // 'tr',
    // 'uk',
    // 'vi',
    // 'zh-Hans',
    // 'zh',
  ],
};

const bootstrap = (app) => {
  console.log(app);
};

export default {
  config,
  bootstrap,
};


src\admin\app.js

const config = {
  locales: ['pt-BR'],
  translations: {
    'pt-BR': {
      'app.components.LeftMenu.navbrand.title': 'SoftMeat Dashboard',
      'Content Manager': 'Gerenciador de Conteúdo',
      'app.components.LeftMenu.collection.title': 'Tipos de Coleção',
      'Settings.permissions': 'Permissões',
      'Settings.roles': 'Funções',
      'Settings.users': 'Usuários',
      'notification.success.saved': 'Salvo com sucesso',
      'global.save': 'Salvar',
      'global.delete': 'Deletar',
      'global.back': 'Voltar',
      'global.cancel': 'Cancelar',
    },
  },
};


src\admin\webpack.config.example.js

'use strict';

/* eslint-disable no-unused-vars */
module.exports = (config, webpack) => {
  // Note: we provide webpack above so you should not `require` it
  // Perform customizations to webpack config
  // Important: return the modified config
  return config;
};


src\api\carrossel-treinamento\content-types\carrossel-treinamento\schema.json

{
  "kind": "collectionType",
  "collectionName": "carrossel_treinamentos",
  "info": {
    "singularName": "carrossel-treinamento",
    "pluralName": "carrossel-treinamentos",
    "displayName": "Carrossel Treinamento"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "DepoimentosTreinamentos": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": true
    }
  }
}


src\api\carrossel-treinamento\controllers\carrossel-treinamento.js

'use strict';

/**
 * carrossel-treinamento controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::carrossel-treinamento.carrossel-treinamento');


src\api\carrossel-treinamento\routes\carrossel-treinamento.js

'use strict';

/**
 * carrossel-treinamento router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::carrossel-treinamento.carrossel-treinamento');


src\api\carrossel-treinamento\services\carrossel-treinamento.js

'use strict';

/**
 * carrossel-treinamento service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::carrossel-treinamento.carrossel-treinamento');


src\api\cliente\content-types\cliente\schema.json

{
  "kind": "collectionType",
  "collectionName": "clientes",
  "info": {
    "singularName": "cliente",
    "pluralName": "clientes",
    "displayName": "Clientes"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true
    },
    "Logo": {
      "allowedTypes": [
        "images"
      ],
      "type": "media",
      "multiple": false,
      "required": true
    },
    
    "Descricao_Case": {
      "type": "string",
      "required": true
    }
  }
}


src\api\cliente\controllers\cliente.js

'use strict';

/**
 * cliente controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::cliente.cliente');


src\api\cliente\routes\cliente.js

'use strict';

/**
 * cliente router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::cliente.cliente');


src\api\cliente\services\cliente.js

'use strict';

/**
 * cliente service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::cliente.cliente');


src\api\configuracao-geral\content-types\configuracao-geral\schema.json

{
  "kind": "collectionType",
  "collectionName": "configuracao_gerais",
  "info": {
    "singularName": "configuracao-geral",
    "pluralName": "configuracao-gerais",
    "displayName": "Configuracao Geral"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "LogoNavegacao": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\configuracao-geral\controllers\configuracao-geral.js

'use strict';

/**
 * configuracao-geral controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::configuracao-geral.configuracao-geral');


src\api\configuracao-geral\routes\configuracao-geral.js

'use strict';

/**
 * configuracao-geral router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::configuracao-geral.configuracao-geral');


src\api\configuracao-geral\services\configuracao-geral.js

'use strict';

/**
 * configuracao-geral service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::configuracao-geral.configuracao-geral');


src\api\cronograma\content-types\cronograma\schema.json

{
  "kind": "collectionType",
  "collectionName": "cronogramas",
  "info": {
    "singularName": "cronograma",
    "pluralName": "cronogramas",
    "displayName": "Cronogramas",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Data": {
      "type": "date",
      "required": true
    },
    "Cidade": {
      "type": "string",
      "required": true,
      "default": "Ribeirão Preto"
    },
    "Vagas_Totais": {
      "type": "integer",
      "required": true
    },
    "Vagas_Disponiveis": {
      "type": "integer"
    },
    "Ativo": {
      "type": "boolean",
      "default": true,
      "required": true
    },



    "treinamento": {
      "type": "relation",
      "relation": "oneToOne",
      "target": "api::treinamento.treinamento"
    }
  }
}



src\api\cronograma\controllers\cronograma.js

'use strict';

/**
 * cronograma controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::cronograma.cronograma');


src\api\cronograma\routes\cronograma.js

'use strict';

/**
 * cronograma router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::cronograma.cronograma');


src\api\cronograma\services\cronograma.js

'use strict';

/**
 * cronograma service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::cronograma.cronograma');


src\api\curso-online\content-types\curso-online\schema.json

{
  "kind": "collectionType",
  "collectionName": "cursos_online",
  "info": {
    "singularName": "curso-online",
    "pluralName": "cursos-online",
    "displayName": "Cursos Online"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "slug": {
      "type": "uid",
      "targetField": "Nome",
      "required": true
    },
    "Categoria": {
      "type": "enumeration",
      "enum": [
        "Básico",
        "Intermediário",
        "Avançado",
        "Especialização"
      ]
    },
    "Descricao_Catalogo": {
      "type": "text",
      "required": true
    },
    "Descricao": {
      "type": "richtext",
      "required": true
    },
    "Link_Hotmart": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "Imagem": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": ["images"]
    },
    "Ordem_Exibicao": {
      "type": "integer",
      "default": 999
    },
    "Destaque": {
      "type": "boolean",
      "default": false,
      "required": true
    },
    "Meta_Title": {
      "type": "string"
    },
    "Meta_Description": {
      "type": "text"
    }
  }
}


src\api\curso-online\controllers\curso-online.js

'use strict';

/**
 * curso-online controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::curso-online.curso-online');


src\api\curso-online\routes\curso-online.js

'use strict';

/**
 * curso-online router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::curso-online.curso-online');


src\api\curso-online\services\curso-online.js

'use strict';

/**
 * curso-online service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::curso-online.curso-online');


src\api\hero-consultoria\content-types\hero-consultoria\schema.json

{
  "kind": "collectionType",
  "collectionName": "hero_consultorias",
  "info": {
    "singularName": "hero-consultoria",
    "pluralName": "hero-consultorias",
    "displayName": "Hero Consultoria"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Consultor": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\hero-consultoria\controllers\hero-consultoria.js

'use strict';

/**
 * hero-consultoria controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::hero-consultoria.hero-consultoria');


src\api\hero-consultoria\routes\hero-consultoria.js

'use strict';

/**
 * hero-consultoria router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::hero-consultoria.hero-consultoria');


src\api\hero-consultoria\services\hero-consultoria.js

'use strict';

/**
 * hero-consultoria service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::hero-consultoria.hero-consultoria');


src\api\home-consultoria\content-types\home-consultoria\schema.json

{
  "kind": "collectionType",
  "collectionName": "home_consultorias",
  "info": {
    "singularName": "home-consultoria",
    "pluralName": "home-consultorias",
    "displayName": "Home Consultoria"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "ConsultoriaPage": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\home-consultoria\controllers\home-consultoria.js

'use strict';

/**
 * home-consultoria controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::home-consultoria.home-consultoria');


src\api\home-consultoria\routes\home-consultoria.js

'use strict';

/**
 * home-consultoria router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::home-consultoria.home-consultoria');


src\api\home-consultoria\services\home-consultoria.js

'use strict';

/**
 * home-consultoria service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::home-consultoria.home-consultoria');


src\api\home-hero\content-types\home-hero\schema.json

{
  "kind": "collectionType",
  "collectionName": "home_heroes",
  "info": {
    "singularName": "home-hero",
    "pluralName": "home-heroes",
    "displayName": "Home Hero",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "PageHero": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ]
    }
  }
}


src\api\home-hero\controllers\home-hero.js

'use strict';

/**
 * home-hero controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::home-hero.home-hero');


src\api\home-hero\routes\home-hero.js

'use strict';

/**
 * home-hero router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::home-hero.home-hero');


src\api\home-hero\services\home-hero.js

'use strict';

/**
 * home-hero service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::home-hero.home-hero');


src\api\home-treinamento\content-types\home-treinamento\schema.json

{
  "kind": "collectionType",
  "collectionName": "home_treinamentos",
  "info": {
    "singularName": "home-treinamento",
    "pluralName": "home-treinamentos",
    "displayName": "Home Treinamento"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "TreinamentoPage": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\home-treinamento\controllers\home-treinamento.js

'use strict';

/**
 * home-treinamento controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::home-treinamento.home-treinamento');


src\api\home-treinamento\routes\home-treinamento.js

'use strict';

/**
 * home-treinamento router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::home-treinamento.home-treinamento');


src\api\home-treinamento\services\home-treinamento.js

'use strict';

/**
 * home-treinamento service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::home-treinamento.home-treinamento');


src\api\index-destaque\content-types\index-destaque\schema.json

{
  "kind": "singleType",
  "collectionName": "index_destaques",
  "info": {
    "singularName": "index-destaque",
    "pluralName": "index-destaques",
    "displayName": "Index Destaques",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "cursos_em_destaque": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::curso-online.curso-online"
    },
    "Imagem": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": ["images"]
    },
    "produtos_em_destaque": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::produto.produto"
    }
  }
}


src\api\index-destaque\controllers\index-destaque.js

'use strict';

/**
 * index-destaque controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::index-destaque.index-destaque');


src\api\index-destaque\routes\index-destaque.js

'use strict';

/**
 * index-destaque router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::index-destaque.index-destaque');


src\api\index-destaque\services\index-destaque.js

'use strict';

/**
 * index-destaque service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::index-destaque.index-destaque');


src\api\media-reference\controllers\media-reference.js

// src/api/media-reference/controllers/media-reference.js
'use strict';

module.exports = {
  async reference(ctx) {
    try {
      const { url, name, caption, alternativeText } = ctx.request.body;

      if (!url) {
        return ctx.badRequest('URL é obrigatória');
      }

      // Criar o objeto de referência
      const fileData = {
        fileInfo: {
          name: name || url.split('/').pop(),
          url,
          caption,
          alternativeText,
          isExternalUrl: true
        }
      };

      // Usar o serviço de upload existente
      const file = await strapi.plugins.upload.services.upload.upload(fileData);

      return {
        success: true,
        file
      };
    } catch (error) {
      console.error('[Media Reference] Erro:', error);
      return ctx.badRequest('Erro ao referenciar mídia', { error: error.message });
    }
  }
};


src\api\media-reference\routes\media-reference.js

// src/api/media-reference/routes/media-reference.js
'use strict';

module.exports = {
  routes: [
    {
      method: 'POST',
      path: '/api/media/reference',
      handler: 'media-reference.reference',
      config: {
        policies: [],
        description: 'Referencia uma mídia externa por URL'
      }
    }
  ]
};


src\api\produto\content-types\produto\schema.json

{
  "kind": "collectionType",
  "collectionName": "produtos",
  "info": {
    "singularName": "produto",
    "pluralName": "produtos",
    "displayName": "Produtos",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "slug": {
      "type": "uid",
      "targetField": "Nome"
    },
    "Categoria": {
      "type": "enumeration",
      "enum": [
        "Maturados",
        "Fermentados",
        "Defumados",
        "Cozidos",
        "Frescais"
      ],
      "required": true
    },
    "Descricao_Catalogo": {
      "type": "string",
      "required": true
    },
    "Descricao": {
      "type": "richtext",
      "required": true
    },
    "Link_Mercado_Livre": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "Imagem": {
      "type": "media",
      "multiple": true,
      "required": false,
      "allowedTypes": [
        "images"
      ]
    },
    "Destaque": {
      "type": "boolean",
      "default": false,
      "required": true
    },
    "Meta_File": {
      "type": "string"
    },
    "Meta_Description": {
      "type": "text"
    },
    "Disponivel": {
      "type": "boolean",
      "default": true,
      "required": true
    }
  }
}


src\api\produto\controllers\produto.js

'use strict';

/**
 * produto controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::produto.produto');


src\api\produto\routes\produto.js

'use strict';

/**
 * produto router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::produto.produto');


src\api\produto\services\produto.js

'use strict';

/**
 * produto service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::produto.produto');


src\api\sobre-carrossel\content-types\sobre-carrossel\schema.json

{
  "kind": "collectionType",
  "collectionName": "sobre_carrosseis",
  "info": {
    "singularName": "sobre-carrossel",
    "pluralName": "sobre-carrosseis",
    "displayName": "Sobre Carrossel"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Titulo": {
      "type": "string"
    },
    "Imagens": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": true
    }
  }
}


src\api\sobre-carrossel\controllers\sobre-carrossel.js

'use strict';

/**
 * sobre-carrossel controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::sobre-carrossel.sobre-carrossel');


src\api\sobre-carrossel\routes\sobre-carrossel.js

'use strict';

/**
 * sobre-carrossel router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::sobre-carrossel.sobre-carrossel');


src\api\sobre-carrossel\services\sobre-carrossel.js

'use strict';

/**
 * sobre-carrossel service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::sobre-carrossel.sobre-carrossel');


src\api\testemunho\content-types\testemunho\schema.json

{
  "kind": "collectionType",
  "collectionName": "testemunhos",
  "info": {
    "singularName": "testemunho",
    "pluralName": "testemunhos",
    "displayName": "Testemunhos"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true
    },
    "Imagem": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": ["images"]
    },
    "Foto": {
      "allowedTypes": [
        "images"
      ],
      "type": "media",
      "multiple": false,
      "required": true
    },
    "Depoimento": {
      "type": "text"
    },
    "curso_realizado": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::treinamento.treinamento"
    },
    "LinkedIn": {
      "type": "string"
    },
    "Instagram": {
      "type": "string"
    },
    "Facebook": {
      "type": "string"
    },
    "Cargo": {
      "type": "string"
    },
    "Empresa": {
      "type": "string"
    },
    "Ativo": {
      "type": "boolean",
      "default": true
    }
  }
}


src\api\testemunho\controllers\testemunho.js

'use strict';

/**
 * testemunho controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::testemunho.testemunho');


src\api\testemunho\routes\testemunho.js

'use strict';

/**
 * testemunho router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::testemunho.testemunho');


src\api\testemunho\services\testemunho.js

'use strict';

/**
 * testemunho service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::testemunho.testemunho');


src\api\treinamento\content-types\treinamento\schema.json

{
  "kind": "collectionType",
  "collectionName": "treinamentos",
  "info": {
    "singularName": "treinamento",
    "pluralName": "treinamentos",
    "displayName": "Treinamentos",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true
    },
    "Nivel": {
      "type": "enumeration",
      "enum": [
        "Basico",
        "Intermediario",
        "Avancado"
      ],
      "required": true
    },
    "Duracao": {
      "type": "integer",
      "required": true,
      "default": 1
    },
    "Descricao_Catalogo": {
      "type": "text",
      "required": true
    },
    "Topicos": {
      "type": "richtext",
      "required": true
    },
    "Ativo": {
      "type": "boolean",
      "default": false,
      "required": true
    },
    "Ordem": {
      "type": "integer"
    },
    "Meta_Title": {
      "type": "text"
    },
    "Meta_Description": {
      "type": "text"
    }
  }
}


src\api\treinamento\controllers\treinamento.js

'use strict';

/**
 * treinamento controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::treinamento.treinamento');


src\api\treinamento\routes\treinamento.js

'use strict';

/**
 * treinamento router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::treinamento.treinamento');


src\api\treinamento\services\treinamento.js

'use strict';

/**
 * treinamento service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::treinamento.treinamento');


src\extensions\upload\strapi-server.js

// src/extensions/upload/strapi-server.js
module.exports = (plugin) => {
  plugin.services.upload.uploadToEntity = async (params) => {
    console.log('[Upload Debug] Params:', JSON.stringify(params, null, 2));
    return await plugin.services.upload.uploadToEntity(params);
  };

  return plugin;
};


src\index.js

module.exports = {
  register({ strapi }) {
    console.log('=== VERIFICAÇÃO DE AMBIENTE DE PRODUÇÃO ===');
    console.log('NODE_ENV:', process.env.NODE_ENV);
    console.log('DATABASE_CLIENT:', process.env.DATABASE_CLIENT);
    console.log('DATABASE_FILENAME:', process.env.DATABASE_FILENAME);

    // Verificar variáveis R2
    console.log('=== CONFIGURAÇÃO R2 ===');
    console.log('R2_ACCESS_KEY configurado:', !!process.env.R2_ACCESS_KEY);
    console.log('R2_SECRET_KEY configurado:', !!process.env.R2_SECRET_KEY);
    console.log('R2_ENDPOINT:', process.env.R2_ENDPOINT);
    console.log('R2_BUCKET:', process.env.R2_BUCKET);
    console.log('R2_PUBLIC_URL:', process.env.R2_PUBLIC_URL);

    // Verificar permissões de diretório (produção)
    if (process.env.NODE_ENV === 'production') {
      const fs = require('fs');
      const path = require('path');

      const dbPath = process.env.DATABASE_FILENAME;
      const dbDir = path.dirname(dbPath);

      try {
        console.log(`Verificando diretório do banco de dados: ${dbDir}`);
        if (fs.existsSync(dbDir)) {
          console.log('✓ Diretório do banco de dados existe');

          // Verificar permissões
          const dirStats = fs.statSync(dbDir);
          console.log(`  Permissões: ${dirStats.mode}`);

          // Verificar arquivo do banco
          if (fs.existsSync(dbPath)) {
            console.log(`✓ Arquivo do banco de dados existe: ${dbPath}`);
            const fileStats = fs.statSync(dbPath);
            console.log(`  Tamanho: ${(fileStats.size / (1024 * 1024)).toFixed(2)} MB`);
            console.log(`  Permissões: ${fileStats.mode}`);
          } else {
            console.log(`✗ Arquivo do banco de dados não existe: ${dbPath}`);
          }
        } else {
          console.log(`✗ Diretório do banco de dados não existe: ${dbDir}`);
        }
      } catch (error) {
        console.error('Erro ao verificar banco de dados:', error.message);
      }
    }
  },

  bootstrap({ strapi }) {
    // Log de inicialização simplificado
    console.log(`Strapi iniciado em ${process.env.NODE_ENV} mode`);
  }
};


src\middlewares\upload-debug.js

module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    if (ctx.request.url.includes('/upload') && ctx.request.method === 'POST') {
      console.log('=== INTERCEPTANDO REQUISIÇÃO DE UPLOAD ===');
      console.log('Tamanho do corpo:', ctx.request.body ? 'Presente' : 'Ausente');
      console.log('Content-Type:', ctx.request.headers['content-type']);
      console.log('Content-Length:', ctx.request.headers['content-length']);

      try {
        await next();

        console.log('=== RESPOSTA DE UPLOAD ===');
        console.log('Status:', ctx.response.status);
        console.log('Tipo de resposta:', typeof ctx.response.body);
      } catch (error) {
        console.error('=== ERRO NO UPLOAD ===');
        console.error('Mensagem:', error.message);
        console.error('Stack:', error.stack);
        throw error;
      }
    } else {
      await next();
    }
  };
};


src\middlewares\upload-logger.js

// src/middlewares/upload-logger.js
module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    if (ctx.request.url.includes('/upload')) {
      console.log('=== UPLOAD DEBUG ===');
      console.log('Request method:', ctx.request.method);
      console.log('Content-Type:', ctx.request.header['content-type']);

      try {
        await next();
        console.log('Upload response status:', ctx.response.status);
      } catch (error) {
        console.error('Upload error:', error.message);
        console.error('Error stack:', error.stack);
        throw error;
      }
    } else {
      await next();
    }
  };
};


src\provider\r2-upload\index.js

// src/providers/r2-upload/index.js
const AWS = require('aws-sdk');
const path = require('path');

module.exports = {
  init(config) {
    const S3 = new AWS.S3({
      accessKeyId: config.accessKeyId,
      secretAccessKey: config.secretAccessKey,
      endpoint: config.endpoint,
      region: config.region || 'auto',
      s3ForcePathStyle: true,
      signatureVersion: 'v4',
    });

    const publicUrl = config.publicUrl || config.endpoint;

    return {
      async upload(file) {
        const { buffer, hash, ext, mime } = file;

        // Gerar nome de arquivo com hash para evitar colisões
        const filename = `${hash}${ext}`;

        // Definir categoria baseada no mime-type
        let category = 'other';
        if (mime.startsWith('image/')) category = 'images';
        else if (mime.startsWith('video/')) category = 'videos';
        else if (mime.startsWith('audio/')) category = 'audio';

        // Definir chave com categoria
        const Key = `${category}/${filename}`;

        // Upload para R2
        await S3.upload({
          Key,
          Body: Buffer.from(buffer),
          ContentType: mime,
          Bucket: config.bucket,
          ACL: 'public-read'
        }).promise();

        // Formar URL pública correta
        const cleanPublicUrl = publicUrl.endsWith('/')
          ? publicUrl.slice(0, -1)
          : publicUrl;

        file.url = `${cleanPublicUrl}/${Key}`;

        return file;
      },

      async delete(file) {
        // Extrair a chave da URL
        const urlPath = new URL(file.url).pathname;
        const Key = urlPath.startsWith('/') ? urlPath.substring(1) : urlPath;

        try {
          await S3.deleteObject({
            Key,
            Bucket: config.bucket,
          }).promise();
        } catch (error) {
          console.error('Error deleting from R2:', error);
        }
      },
    };
  },
};


src\utils\r2.js

// src/utils/r2.js - versão melhorada
'use strict';

/**
 * Utilitários para manipulação de URLs do Cloudflare R2
 */

/**
 * Formata um caminho de arquivo para uma URL R2 completa
 * @param {string} path - Caminho relativo do arquivo no bucket
 * @returns {string} URL formatada
 */
const formatR2Url = (path) => {
  if (!path) return '';

  // Sanitizar o caminho
  const cleanPath = String(path).startsWith('/') ? path.substring(1) : path;

  // Usar domínio personalizado se disponível
  if (process.env.CF_PUBLIC_ACCESS_URL) {
    const domain = process.env.CF_PUBLIC_ACCESS_URL.endsWith('/')
      ? process.env.CF_PUBLIC_ACCESS_URL.slice(0, -1)
      : process.env.CF_PUBLIC_ACCESS_URL;
    return `${domain}/${cleanPath}`;
  }

  // Fallback para URL direta do R2
  if (process.env.CF_ENDPOINT && process.env.CF_BUCKET) {
    const endpoint = process.env.CF_ENDPOINT.endsWith('/')
      ? process.env.CF_ENDPOINT.slice(0, -1)
      : process.env.CF_ENDPOINT;
    return `${endpoint}/${process.env.CF_BUCKET}/${cleanPath}`;
  }

  // Se tudo falhar, retornar o caminho como está
  console.warn('[R2 URL Formatter] Configuração R2 incompleta, usando caminho original');
  return path;
};

module.exports = {
  formatR2Url
};


src\utils\r2Helper.js

'use strict';

/**
 * Utilitários para auxiliar no tratamento de URLs do R2
 */

const isR2Url = (url) => {
  if (!url) return false;

  const r2Patterns = [
    'images.softmeat.com.br',
    '.r2.cloudflarestorage.com',
    process.env.CF_PUBLIC_ACCESS_URL,
    process.env.R2_CUSTOM_DOMAIN
  ].filter(Boolean);

  return r2Patterns.some(pattern => pattern && url.includes(pattern));
};

const formatR2Url = (url) => {
  if (!url || !isR2Url(url)) return url;

  // Se já estiver usando o domínio público, retornar como está
  if (process.env.CF_PUBLIC_ACCESS_URL && url.includes(process.env.CF_PUBLIC_ACCESS_URL)) {
    return url;
  }

  // Se estiver usando o endpoint direto do R2, converter para domínio público
  if (process.env.CF_ENDPOINT && process.env.CF_BUCKET && url.includes(process.env.CF_ENDPOINT)) {
    const publicUrl = process.env.CF_PUBLIC_ACCESS_URL;
    if (!publicUrl) return url;

    const cleanPublicUrl = publicUrl.endsWith('/') ? publicUrl.slice(0, -1) : publicUrl;

    // Extrair o caminho do objeto no bucket
    const regex = new RegExp(`.*?${process.env.CF_BUCKET}/?(.*)`, 'i');
    const match = url.match(regex);

    if (match && match[1]) {
      return `${cleanPublicUrl}/${match[1]}`;
    }
  }

  return url;
};

module.exports = {
  isR2Url,
  formatR2Url
};


