# Estrutura do Projeto SoftMeat - backend_main

├── public
│   ├── uploads
├── src
│   ├── admin
│   ├── api
│   │   ├── carrossel-treinamento
│   │   │   ├── content-types
│   │   │   │   └── carrossel-treinamento
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── cliente
│   │   │   ├── content-types
│   │   │   │   └── cliente
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── configuracao-geral
│   │   │   ├── content-types
│   │   │   │   └── configuracao-geral
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── cronograma
│   │   │   ├── content-types
│   │   │   │   └── cronograma
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── curso-online
│   │   │   ├── content-types
│   │   │   │   └── curso-online
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── hero-consultoria
│   │   │   ├── content-types
│   │   │   │   └── hero-consultoria
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── home-consultoria
│   │   │   ├── content-types
│   │   │   │   └── home-consultoria
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── home-hero
│   │   │   ├── content-types
│   │   │   │   └── home-hero
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── home-treinamento
│   │   │   ├── content-types
│   │   │   │   └── home-treinamento
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── index-destaque
│   │   │   ├── content-types
│   │   │   │   └── index-destaque
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── media-reference
│   │   │   ├── controllers
│   │   │   └── routes
│   │   ├── produto
│   │   │   ├── content-types
│   │   │   │   └── produto
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── sobre-carrossel
│   │   │   ├── content-types
│   │   │   │   └── sobre-carrossel
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── testemunho
│   │   │   ├── content-types
│   │   │   │   └── testemunho
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   │   ├── treinamento
│   │   │   ├── content-types
│   │   │   │   └── treinamento
│   │   │   ├── controllers
│   │   │   ├── routes
│   │   │   └── services
│   ├── extensions
│   │   ├── upload
│   │   │   ├── services
│   ├── middlewares
│   ├── provider
│   │   └── r2-upload
│   ├── utils
├── .env
├── package.json


.env

# Configuração do Servidor
HOST=0.0.0.0
PORT=1337
APP_KEYS=chave1,chave2,chave3,chave4
API_TOKEN_SALT=tokenSalt
ADMIN_JWT_SECRET=jwtSecret
TRANSFER_TOKEN_SALT=transferSalt
JWT_SECRET=jwtSecret
DATABASE_CLIENT=sqlite
DATABASE_FILENAME=/mnt/data/softmeat-db/data.db
URL=http://localhost:1337
PUBLIC_URL=http://localhost:1337
WEBHOOKS_POPULATE_RELATIONS=false

# R2 Configuration
R2_ACCESS_KEY=c5a5705f56ec2c7d0198c9b712eda3c4
R2_SECRET_KEY=f01299d076461e261024d2778df30f9e23e6b74674633efa918798a58b806d33
R2_ENDPOINT=https://950693b7edbd202561c3d20e4a036247.r2.cloudflarestorage.com
R2_BUCKET=softmeat-storage
R2_REGION=auto
R2_PUBLIC_URL=https://storage.softmeat.com.br


backups\20250309\extensions\extensions\upload\middlewares\imageProcessor.js

// src/extensions/upload/middlewares/imageProcessor.js (versão simplificada para produção)
'use strict';

const sharp = require('sharp');
const fs = require('fs');

module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    // Em produção, logging detalhado
    if (ctx.request.url.includes('/upload') && ctx.request.method === 'POST') {
      const files = ctx.request.files?.files || [];

      if (files.length > 0) {
        for (const file of files) {
          if (file && file.type && file.type.startsWith('image/')) {
            try {
              // Apenas verificar se a imagem é válida sem modificá-la
              const metadata = await sharp(file.path).metadata();
              console.log(`[PROD] Imagem verificada: ${file.name}, formato: ${metadata.format}, tamanho: ${file.size} bytes`);

              // Verificar se o arquivo tem conteúdo
              const stats = fs.statSync(file.path);
              if (stats.size === 0) {
                console.error(`[PROD ERROR] Arquivo vazio detectado: ${file.name}`);
              } else {
                console.log(`[PROD] Arquivo válido: ${file.name}, tamanho: ${stats.size} bytes`);
              }
            } catch (error) {
              console.error(`[PROD ERROR] Falha ao verificar imagem ${file.name}: ${error.message}`);
            }
          }
        }
      }
    }

    // Prosseguir sem processar a imagem para evitar problemas
    await next();
  };
};


backups\20250309\extensions\extensions\upload\services\format-url.js

'use strict';

/**
 * Serviço aprimorado para formatação de URLs do R2
 */

/**
 * Extrai o domínio de uma URL
 * @param {string} url - URL para extrair o domínio
 * @returns {string} Domínio da URL
 */
function extractDomain(url) {
  if (!url) return '';
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (error) {
    console.error(`[R2 URL] Erro ao extrair domínio: ${error.message}`);
    return '';
  }
}

/**
 * Formata URL de arquivo para usar o domínio público do R2
 * @param {Object} file - Objeto de arquivo
 * @returns {Object} Arquivo com URL atualizada
 */
function formatFileUrl(file) {
  if (!file || !file.url) return file;

  try {
    // Obter configurações do R2
    const publicDomain = process.env.CF_PUBLIC_ACCESS_URL;
    const r2Endpoint = process.env.CF_ENDPOINT;
    const bucket = process.env.CF_BUCKET;

    if (!publicDomain) {
      console.log(`[R2 URL] Domínio público não configurado, mantendo URL original: ${file.url}`);
      return file;
    }

    // Log para depuração
    console.log(`[R2 URL] Processando URL: ${file.url}`);

    const currentDomain = extractDomain(file.url);
    const publicUrlDomain = extractDomain(publicDomain);

    // Se já estiver usando o domínio público, manter como está
    if (currentDomain === publicUrlDomain) {
      console.log(`[R2 URL] URL já usa domínio público, mantendo: ${file.url}`);
      return file;
    }

    // Verificar se está usando o endpoint R2 direto
    const isUsingR2Endpoint = r2Endpoint && file.url.includes(r2Endpoint);

    // Se não estiver usando endpoint R2 nem domínio público, pode ser URL externa
    if (!isUsingR2Endpoint && currentDomain !== publicUrlDomain) {
      console.log(`[R2 URL] Possível URL externa, verificando estrutura: ${file.url}`);

      // Verificar se é uma URL válida
      try {
        new URL(file.url);
      } catch (e) {
        console.log(`[R2 URL] URL inválida, mantendo como está: ${file.url}`);
        return file;
      }

      // Se o domínio for diferente e não for do R2, é provavelmente uma URL externa
      // Preserva-la se for válida
      if (!currentDomain.includes('cloudflarestorage.com') &&
          !currentDomain.includes('softmeat.com.br')) {
        console.log(`[R2 URL] URL externa confirmada, mantendo: ${file.url}`);
        return file;
      }
    }

    // Se chegamos aqui, precisamos reformatar a URL para usar o domínio público

    // Extrair o caminho relativo da URL
    let relativePath = '';
    try {
      const urlObj = new URL(file.url);
      relativePath = urlObj.pathname;

      // Remover prefixo do bucket se presente
      if (bucket && relativePath.includes(bucket)) {
        const bucketIndex = relativePath.indexOf(bucket);
        relativePath = relativePath.substring(bucketIndex + bucket.length);
      }

      // Remover barras iniciais
      while (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
    } catch (error) {
      console.error(`[R2 URL] Erro ao extrair caminho: ${error.message}`);
      return file;
    }

    // Formar nova URL com domínio público
    const formattedPublicDomain = publicDomain.endsWith('/')
      ? publicDomain.slice(0, -1)
      : publicDomain;

    const newUrl = `${formattedPublicDomain}/${relativePath}`;

    console.log(`[R2 URL] URL reformatada: ${file.url} -> ${newUrl}`);

    // Criar cópia do arquivo com URL atualizada
    return {
      ...file,
      url: newUrl
    };
  } catch (error) {
    console.error(`[R2 URL] Erro ao formatar URL: ${error.message}`);
    // Em caso de erro, retornar arquivo original sem modificações
    return file;
  }
}

module.exports = {
  formatFileUrl
};


backups\20250309\extensions\extensions\upload\strapi-server.js

'use strict';

module.exports = (plugin) => {
  const originalUpload = plugin.services.upload.upload;

  // Função para verificar se uma URL é do R2
  const isR2Url = (url) => {
    const patterns = [
      'storage.softmeat.com.br',
      '.r2.cloudflarestorage.com',
      process.env.R2_PUBLIC_URL,
      process.env.R2_ENDPOINT,
    ].filter(Boolean);

    return url && patterns.some(pattern => url.includes(pattern));
  };

  // Sobrescrever o método de upload
  plugin.services.upload.upload = async (fileData, config) => {
    // Se for uma URL externa do R2, apenas referenciar sem fazer upload
    if (fileData && fileData.fileInfo && fileData.fileInfo.url && isR2Url(fileData.fileInfo.url)) {
      console.log(`[R2] URL externa detectada: ${fileData.fileInfo.url}`);

      // Extrair informações do arquivo
      const fileName = fileData.fileInfo.url.split('/').pop();
      const ext = getExtension(fileName);
      const mime = getMimeType(ext);

      // Retornar objeto sem fazer upload (apenas referência)
      return {
        name: fileName || fileData.fileInfo.name,
        url: fileData.fileInfo.url,
        provider: 'aws-s3',
        ext: ext || fileData.fileInfo.ext,
        mime: mime || fileData.fileInfo.mime,
        size: fileData.fileInfo.size || 0,
        isExternalUrl: true
      };
    }

    // Caso contrário, continuar com o upload normal
    return await originalUpload(fileData, config);
  };

  // Interceptar para normalizar URLs nas respostas
  const originalFindOne = plugin.services.upload.findOne;
  if (originalFindOne) {
    plugin.services.upload.findOne = async (id, config) => {
      const file = await originalFindOne(id, config);

      if (file && file.url && isR2Url(file.url)) {
        file.url = formatR2Url(file.url);
      }

      return file;
    };
  }

  // Interceptar para normalizar URLs nas listagens
  const originalFind = plugin.services.upload.find;
  if (originalFind) {
    plugin.services.upload.find = async (params, config) => {
      const files = await originalFind(params, config);

      if (Array.isArray(files)) {
        files.forEach(file => {
          if (file.url && isR2Url(file.url)) {
            file.url = formatR2Url(file.url);
          }
        });
      }

      return files;
    };
  }

  return plugin;
};

// Função para formatar URLs R2
function formatR2Url(url) {
  if (!url) return url;

  const publicUrl = process.env.R2_PUBLIC_URL || 'https://storage.softmeat.com.br';

  // Se já estiver usando o domínio público
  if (url.includes(publicUrl)) return url;

  try {
    // Extrair o caminho relativo
    let relativePath = '';
    const urlObj = new URL(url);
    const bucketName = process.env.R2_BUCKET || 'softmeat-storage';

    // Tentar diferentes formatos de URL
    if (url.includes('.r2.cloudflarestorage.com')) {
      const parts = urlObj.pathname.split('/');
      const bucketIndex = parts.findIndex(part => part === bucketName);

      if (bucketIndex >= 0 && bucketIndex < parts.length - 1) {
        relativePath = parts.slice(bucketIndex + 1).join('/');
      }
    } else {
      // Formato simples de URL
      relativePath = urlObj.pathname;
      if (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
    }

    if (relativePath) {
      const cleanPublicUrl = publicUrl.endsWith('/') ?
                            publicUrl.slice(0, -1) :
                            publicUrl;
      return `${cleanPublicUrl}/${relativePath}`;
    }

    return url;
  } catch (error) {
    console.error(`[R2] Erro ao formatar URL: ${error.message}`);
    return url;
  }
}

// Funções auxiliares
function getExtension(filename) {
  if (!filename) return '';
  const parts = filename.split('.');
  return parts.length > 1 ? `.${parts.pop().toLowerCase()}` : '';
}

function getMimeType(ext) {
  if (!ext) return 'application/octet-stream';

  const types = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.svg': 'image/svg+xml',
    '.pdf': 'application/pdf',
    '.doc': 'application/msword',
    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    '.xls': 'application/vnd.ms-excel',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    '.ppt': 'application/vnd.ms-powerpoint',
    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    '.mp4': 'video/mp4',
    '.mp3': 'audio/mpeg',
    '.wav': 'audio/wav',
    '.zip': 'application/zip',
    '.txt': 'text/plain',
    '.csv': 'text/csv',
    '.json': 'application/json',
  };

  return types[ext.toLowerCase()] || 'application/octet-stream';
}


backups\20250309\extensions\upload\middlewares\imageProcessor.js

// src/extensions/upload/middlewares/imageProcessor.js (versão simplificada para produção)
'use strict';

const sharp = require('sharp');
const fs = require('fs');

module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    // Em produção, logging detalhado
    if (ctx.request.url.includes('/upload') && ctx.request.method === 'POST') {
      const files = ctx.request.files?.files || [];

      if (files.length > 0) {
        for (const file of files) {
          if (file && file.type && file.type.startsWith('image/')) {
            try {
              // Apenas verificar se a imagem é válida sem modificá-la
              const metadata = await sharp(file.path).metadata();
              console.log(`[PROD] Imagem verificada: ${file.name}, formato: ${metadata.format}, tamanho: ${file.size} bytes`);

              // Verificar se o arquivo tem conteúdo
              const stats = fs.statSync(file.path);
              if (stats.size === 0) {
                console.error(`[PROD ERROR] Arquivo vazio detectado: ${file.name}`);
              } else {
                console.log(`[PROD] Arquivo válido: ${file.name}, tamanho: ${stats.size} bytes`);
              }
            } catch (error) {
              console.error(`[PROD ERROR] Falha ao verificar imagem ${file.name}: ${error.message}`);
            }
          }
        }
      }
    }

    // Prosseguir sem processar a imagem para evitar problemas
    await next();
  };
};


backups\20250309\extensions\upload\services\format-url.js

'use strict';

/**
 * Serviço aprimorado para formatação de URLs do R2
 */

/**
 * Extrai o domínio de uma URL
 * @param {string} url - URL para extrair o domínio
 * @returns {string} Domínio da URL
 */
function extractDomain(url) {
  if (!url) return '';
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (error) {
    console.error(`[R2 URL] Erro ao extrair domínio: ${error.message}`);
    return '';
  }
}

/**
 * Formata URL de arquivo para usar o domínio público do R2
 * @param {Object} file - Objeto de arquivo
 * @returns {Object} Arquivo com URL atualizada
 */
function formatFileUrl(file) {
  if (!file || !file.url) return file;

  try {
    // Obter configurações do R2
    const publicDomain = process.env.CF_PUBLIC_ACCESS_URL;
    const r2Endpoint = process.env.CF_ENDPOINT;
    const bucket = process.env.CF_BUCKET;

    if (!publicDomain) {
      console.log(`[R2 URL] Domínio público não configurado, mantendo URL original: ${file.url}`);
      return file;
    }

    // Log para depuração
    console.log(`[R2 URL] Processando URL: ${file.url}`);

    const currentDomain = extractDomain(file.url);
    const publicUrlDomain = extractDomain(publicDomain);

    // Se já estiver usando o domínio público, manter como está
    if (currentDomain === publicUrlDomain) {
      console.log(`[R2 URL] URL já usa domínio público, mantendo: ${file.url}`);
      return file;
    }

    // Verificar se está usando o endpoint R2 direto
    const isUsingR2Endpoint = r2Endpoint && file.url.includes(r2Endpoint);

    // Se não estiver usando endpoint R2 nem domínio público, pode ser URL externa
    if (!isUsingR2Endpoint && currentDomain !== publicUrlDomain) {
      console.log(`[R2 URL] Possível URL externa, verificando estrutura: ${file.url}`);

      // Verificar se é uma URL válida
      try {
        new URL(file.url);
      } catch (e) {
        console.log(`[R2 URL] URL inválida, mantendo como está: ${file.url}`);
        return file;
      }

      // Se o domínio for diferente e não for do R2, é provavelmente uma URL externa
      // Preserva-la se for válida
      if (!currentDomain.includes('cloudflarestorage.com') &&
          !currentDomain.includes('softmeat.com.br')) {
        console.log(`[R2 URL] URL externa confirmada, mantendo: ${file.url}`);
        return file;
      }
    }

    // Se chegamos aqui, precisamos reformatar a URL para usar o domínio público

    // Extrair o caminho relativo da URL
    let relativePath = '';
    try {
      const urlObj = new URL(file.url);
      relativePath = urlObj.pathname;

      // Remover prefixo do bucket se presente
      if (bucket && relativePath.includes(bucket)) {
        const bucketIndex = relativePath.indexOf(bucket);
        relativePath = relativePath.substring(bucketIndex + bucket.length);
      }

      // Remover barras iniciais
      while (relativePath.startsWith('/')) {
        relativePath = relativePath.substring(1);
      }
    } catch (error) {
      console.error(`[R2 URL] Erro ao extrair caminho: ${error.message}`);
      return file;
    }

    // Formar nova URL com domínio público
    const formattedPublicDomain = publicDomain.endsWith('/')
      ? publicDomain.slice(0, -1)
      : publicDomain;

    const newUrl = `${formattedPublicDomain}/${relativePath}`;

    console.log(`[R2 URL] URL reformatada: ${file.url} -> ${newUrl}`);

    // Criar cópia do arquivo com URL atualizada
    return {
      ...file,
      url: newUrl
    };
  } catch (error) {
    console.error(`[R2 URL] Erro ao formatar URL: ${error.message}`);
    // Em caso de erro, retornar arquivo original sem modificações
    return file;
  }
}

module.exports = {
  formatFileUrl
};


backups\20250309\extensions\upload\strapi-server.js

// src/extensions/upload/strapi-server.js
'use strict';

module.exports = (plugin) => {
  const originalUpload = plugin.services.upload.upload;

  // Função para verificar se uma URL é do R2
  const isR2Url = (url) => {
    const patterns = [
      'images.softmeat.com.br',
      '.r2.cloudflarestorage.com',
      process.env.R2_PUBLIC_URL,
      process.env.R2_ENDPOINT,
    ].filter(Boolean);

    return url && patterns.some(pattern => url.includes(pattern));
  };

  // Função para converter URLs diretas do R2 para o domínio personalizado
  const formatR2Url = (url) => {
    if (!url || !isR2Url(url)) return url;

    const publicUrl = process.env.R2_PUBLIC_URL || 'https://images.softmeat.com.br';

    // Se já estiver usando o domínio público
    if (url.includes(publicUrl)) return url;

    try {
      // Extrair o caminho relativo
      let relativePath = '';
      const urlObj = new URL(url);
      const bucketName = process.env.R2_BUCKET || 'softmeat-prod';

      // Tentar diferentes formatos de URL
      if (url.includes('.r2.cloudflarestorage.com')) {
        const parts = urlObj.pathname.split('/');
        const bucketIndex = parts.findIndex(part => part === bucketName);

        if (bucketIndex >= 0 && bucketIndex < parts.length - 1) {
          relativePath = parts.slice(bucketIndex + 1).join('/');
        }
      } else {
        // Formato simples de URL
        relativePath = urlObj.pathname;
        if (relativePath.startsWith('/')) {
          relativePath = relativePath.substring(1);
        }
      }

      if (relativePath) {
        const cleanPublicUrl = publicUrl.endsWith('/') ?
                              publicUrl.slice(0, -1) :
                              publicUrl;
        return `${cleanPublicUrl}/${relativePath}`;
      }

      return url;
    } catch (error) {
      console.error(`[R2] Erro ao formatar URL: ${error.message}`);
      return url;
    }
  };

  // Sobrescrever o método de upload
  plugin.services.upload.upload = async (fileData, config) => {
    // Se tiver uma URL e for do R2, apenas referenciar
    if (fileData && fileData.url && isR2Url(fileData.url)) {
      console.log(`[R2] URL externa detectada: ${fileData.url}`);

      // Normalizar a URL
      const normalizedUrl = formatR2Url(fileData.url);
      console.log(`[R2] URL normalizada: ${normalizedUrl}`);

      // Extrair informações do arquivo
      const fileName = normalizedUrl.split('/').pop();
      const ext = getExtension(fileName);
      const mime = getMimeType(ext);

      // Retornar objeto sem fazer upload (apenas referência)
      return {
        ...fileData,
        url: normalizedUrl,
        provider: 'aws-s3',
        name: fileName || fileData.name,
        ext: ext || fileData.ext,
        mime: mime || fileData.mime,
        size: fileData.size || 0,
        isExternalUrl: true
      };
    }

    // Caso contrário, continuar com o upload normal
    return await originalUpload(fileData, config);
  };

  // Interceptar para normalizar URLs nas respostas
  const originalFindOne = plugin.services.upload.findOne;
  if (originalFindOne) {
    plugin.services.upload.findOne = async (id, config) => {
      const file = await originalFindOne(id, config);

      if (file && file.url && isR2Url(file.url)) {
        file.url = formatR2Url(file.url);
      }

      return file;
    };
  }

  // Interceptar para normalizar URLs nas listagens
  const originalFind = plugin.services.upload.find;
  if (originalFind) {
    plugin.services.upload.find = async (params, config) => {
      const files = await originalFind(params, config);

      if (Array.isArray(files)) {
        files.forEach(file => {
          if (file.url && isR2Url(file.url)) {
            file.url = formatR2Url(file.url);
          }
        });
      }

      return files;
    };
  }

  return plugin;
};

// Funções auxiliares
function getExtension(filename) {
  if (!filename) return '';
  const parts = filename.split('.');
  return parts.length > 1 ? `.${parts.pop()}` : '';
}

function getMimeType(ext) {
  if (!ext) return 'application/octet-stream';

  const types = {
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.webp': 'image/webp',
    '.svg': 'image/svg+xml',
  };

  return types[ext.toLowerCase()] || 'application/octet-stream';
}


backups\20250309\middlewares.js

module.exports = ({ env }) => [
  'strapi::errors',
  {
    name: 'strapi::security',
    config: {
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          'connect-src': [
            "'self'",
            'https:',
            'http:',
            env("CF_ENDPOINT", "").replace(/^https?:\/\//, ""),
            env("CF_PUBLIC_ACCESS_URL", "").replace(/^https?:\/\//, ""),
            '*.r2.cloudflarestorage.com'
          ],
          'img-src': [
            "'self'",
            'data:',
            'blob:',
            'dl.airtable.com',
            env("CF_ENDPOINT", "").replace(/^https?:\/\//, ""),
            env("CF_PUBLIC_ACCESS_URL", "").replace(/^https?:\/\//, ""),
            '*.r2.cloudflarestorage.com',
            '*.cloudflare.com',
            '*.softmeat.com.br',
            'market-assets.strapi.io',
            '*'  // Temporariamente permissivo durante testes
          ],
          'media-src': [
            "'self'",
            'data:',
            'blob:',
            'dl.airtable.com',
            env("CF_ENDPOINT", "").replace(/^https?:\/\//, ""),
            env("CF_PUBLIC_ACCESS_URL", "").replace(/^https?:\/\//, ""),
            '*.r2.cloudflarestorage.com',
            '*.cloudflare.com',
            '*.softmeat.com.br',
            'market-assets.strapi.io',
            '*'  // Temporariamente permissivo durante testes
          ],
          'script-src': ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
          'frame-ancestors': null,
          upgradeInsecureRequests: null,
        },
      },
      frameguard: false,
    },
  },
  {
    name: 'strapi::body',
    config: {
      jsonLimit: '10mb',
      formLimit: '50mb',
      textLimit: '10mb',
      formidable: {
        maxFileSize: 50 * 1024 * 1024, // 50MB
        multiples: true,
        keepExtensions: true
      },
    },
  },
  {
    name: 'strapi::cors',
    config: {
      headers: '*',
      origin: [
        'http://localhost:1337',
        'http://localhost:3000',
        'http://localhost:4321',
        'https://softmeat.com.br',
        'https://www.softmeat.com.br',
        'https://softmeat-backend-production.up.railway.app',
        'https://softmeat.pages.dev',
        env("CF_PUBLIC_ACCESS_URL", "https://images.softmeat.com.br"),
        env("CF_ENDPOINT", "")
      ].filter(Boolean),
      methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'],
      keepHeaderOnError: true,
      credentials: true,
      maxAge: 31536000,
      exposedHeaders: ['Content-Range', 'X-Content-Range']
    },
  },
  // Remover temporariamente o middleware personalizado
  // {
  //   name: 'global::imageR2Handler',
  //   config: {}
  // },
  'strapi::poweredBy',
  'strapi::logger',
  'strapi::query',
  'strapi::body',
  'strapi::session',
  'strapi::favicon',
  'strapi::public',
];


backups\20250309\plugins.js

// config/plugins.js
const path = require('path');

module.exports = ({ env }) => ({
  'users-permissions': {
    config: {
      jwtSecret: env('JWT_SECRET'),
    },
  },
  upload: {
    config: {
      provider: '@strapi/provider-upload-aws-s3',
      providerOptions: {
        accessKeyId: env('R2_ACCESS_KEY'),
        secretAccessKey: env('R2_SECRET_KEY'),
        region: env('R2_REGION', 'auto'),
        endpoint: env('R2_ENDPOINT'),
        params: {
          Bucket: env('R2_BUCKET'),
          ACL: 'public-read',
        },
        customDomain: env('R2_PUBLIC_URL')
      },
      actionOptions: {
        upload: {
          ACL: 'public-read',
          customPath: (file) => {
            // Função para sanitizar strings
            const sanitizeString = (str) => {
              if (!str) return '';
              return str
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove acentos
                .replace(/[^\w\-]/g, '-')        // Substitui caracteres especiais por hífen
                .replace(/\-+/g, '-')            // Remove hífens consecutivos
                .toLowerCase();                   // Converte para minúsculas
            };

            // Se for uma URL externa, retornar a URL completa sem modificação
            if (file.isExternalUrl && file.url) {
              return file.url;
            }

            // Detectar o tipo de recurso
            const resourceType = file.mime?.startsWith('image/') ? 'images' :
                               file.mime?.startsWith('video/') ? 'videos' :
                               file.mime?.startsWith('audio/') ? 'audios' : 'files';

            // Determinar a categoria com base no contexto do upload
            let category = 'geral';

            // Tentar determinar a categoria baseado no tipo de conteúdo relacionado
            if (file.related) {
              // Extrair o modelo de relacionamento
              const relatedType = file.related.split('.')[0];

              // Mapeamento simplificado de categorias
              const categoryMap = {
                'produto': 'produtos',
                'curso-online': 'cursos',
                'testemunho': 'testemunhos',
                'cliente': 'clientes',
                'hero-consultoria': 'consultoria',
                'home-consultoria': 'consultoria',
                'home-hero': 'index',
                'index-destaque': 'index',
                'sobre-carrossel': 'institucional',
                'carrossel-treinamento': 'testemunhos',
                'treinamento': 'treinamentos',
                'cronograma': 'treinamentos',
                'home-treinamento': 'treinamentos',
                'configuracao-geral': 'logo'
              };

              // Obter categoria do mapeamento ou usar 'geral' como fallback
              category = categoryMap[relatedType] || 'geral';
            }

            // Sanitizar a categoria
            category = sanitizeString(category);

            // Gerar nome de arquivo sem caracteres especiais mas mantendo a extensão
            const nameWithoutExt = path.basename(file.name, file.ext);
            const sanitizedName = sanitizeString(nameWithoutExt);
            const extension = file.ext.startsWith('.') ? file.ext.substring(1) : file.ext;

            // Evitar nomes muito longos, limitando a 30 caracteres + extensão
            const truncatedName = sanitizedName.length > 30
              ? sanitizedName.substring(0, 30)
              : sanitizedName;

            // Garantir que o hash seja único e esteja presente
            const shortHash = (file.hash || Date.now().toString()).substring(0, 8);

            // Gerar o nome final do arquivo
            const fileName = `${truncatedName}-${shortHash}.${extension}`;

            // Caminho completo no formato categoria/nome-arquivo
            const finalPath = `${category}/${fileName}`;

            if (env('DEBUG') === 'true') {
              console.log('[Upload Path]', {
                original: file.name,
                category: category,
                path: finalPath
              });
            }

            return finalPath;
          }
        },
        uploadStream: {
          ACL: 'public-read'
        },
        delete: {},
      },
    },
  },
});


config\admin.js

module.exports = ({ env }) => ({
  auth: {
    secret: env('ADMIN_JWT_SECRET'),
  },
  apiToken: {
    salt: env('API_TOKEN_SALT'),
  },
  transfer: {
    token: {
      salt: env('TRANSFER_TOKEN_SALT'),
    },
  },
  flags: {
    nps: env.bool('FLAG_NPS', false),
    promoteEE: env.bool('FLAG_PROMOTE_EE', false),
  },
  watchIgnoreFiles: [
    '**/config/sync/**',
  ],
});


config\api.js

module.exports = {
  rest: {
    defaultLimit: 25,
    maxLimit: 100,
    withCount: true,
  },
  responses: {
    privateAttributes: ['_v', 'id', 'created_at'],
  },
  webhook: {
    populateRelations: false,
  },
};


config\database.js

// config/database.js
module.exports = ({ env }) => ({
  connection: {
    client: 'postgres',
    connection: {
      host: env('DATABASE_HOST'),
      port: env.int('DATABASE_PORT', 5432),
      database: env('DATABASE_NAME'),
      user: env('DATABASE_USERNAME'),
      password: env('DATABASE_PASSWORD'),
      ssl: env.bool('DATABASE_SSL', false) ?
        { rejectUnauthorized: env.bool('DATABASE_SSL_SELF', false) } :
        false,
    },
  },
});


config\functions\bootstrap.js

'use strict';

module.exports = () => {
  // Função de bootstrap
  strapi.log.info('Starting Strapi server...');

  // Configurações iniciais
  strapi.log.info('Checking database connection...');

  // Log de configurações importantes
  strapi.log.info(`Server URL: ${strapi.config.get('server.url', 'not set')}`);
  strapi.log.info(`Database Client: ${strapi.config.get('database.connection.client', 'not set')}`);
  strapi.log.info(`Database Path: ${strapi.config.get('database.connection.connection.filename', 'not set')}`);
};


config\middlewares\debug.js

// config/middlewares/debug.js
module.exports = (config, { strapi }) => {
  strapi.log.info("============ DEBUG ENVIRONMENT VARIABLES ============");
  strapi.log.info("R2_ENDPOINT:", process.env.R2_ENDPOINT);
  strapi.log.info("R2_BUCKET:", process.env.R2_BUCKET);
  strapi.log.info("R2_CUSTOM_DOMAIN:", process.env.R2_CUSTOM_DOMAIN);

  return async (ctx, next) => {
    // Continuar para o próximo middleware
    await next();
  };
};


config\middlewares\r2.js

module.exports = ({ env }) => ({
  settings: {
    r2Storage: {
      enabled: true,
      config: {
        provider: '@strapi/provider-upload-aws-s3',
        providerOptions: {
          accessKeyId: env('R2_ACCESS_KEY'),
          secretAccessKey: env('R2_SECRET_KEY'),
          endpoint: env('R2_ENDPOINT'),
          params: {
            Bucket: env('R2_BUCKET'),
          },
          region: env('R2_REGION', 'auto'),
        },
      },
    },
  },
});


config\middlewares.js

module.exports = [
  'strapi::errors',
  {
    name: 'strapi::security',
    config: {
      contentSecurityPolicy: {
        useDefaults: true,
        directives: {
          'img-src': ["'self'", 'data:', 'blob:', 'storage.softmeat.com.br', '*.r2.cloudflarestorage.com'],
          'media-src': ["'self'", 'data:', 'blob:', 'storage.softmeat.com.br', '*.r2.cloudflarestorage.com'],
        },
      },
    },
  },
  'strapi::cors',
  'strapi::poweredBy',
  'strapi::logger',
  'strapi::query',
  'strapi::body',
  'strapi::session',
  'strapi::favicon',
  'strapi::public',
];


config\plugins-funcional.js

module.exports = ({ env }) => ({
  upload: {
    config: {
      provider: '@strapi/provider-upload-aws-s3',
      providerOptions: {
        accessKeyId: env('R2_ACCESS_KEY'),
        secretAccessKey: env('R2_SECRET_KEY'),
        endpoint: env('R2_ENDPOINT'),
        params: {
          Bucket: env('R2_BUCKET'),
          ACL: 'public-read',
        },
        region: env('R2_REGION', 'auto'),
        baseUrl: env('R2_PUBLIC_URL')
      },
      actionOptions: {
        upload: {
          ACL: 'public-read',
          customPath: (file) => {
            // Determine folder based on file type
            const type = file.mime.split('/')[0];
            let folder = 'outros';

            if (type === 'image') folder = 'imagens';
            else if (type === 'video') folder = 'videos';
            else if (type === 'audio') folder = 'audios';

            // Add related model as subfolder if available
            if (file.related) {
              const model = file.related.split('.')[0];
              return `${folder}/${model}/${file.hash}${file.ext}`;
            }

            return `${folder}/${file.hash}${file.ext}`;
          }
        }
      }
    },
  },
});


config\plugins.js

module.exports = ({ env }) => ({
  upload: {
    config: {
      provider: '@strapi/provider-upload-aws-s3',
      providerOptions: {
        accessKeyId: env('R2_ACCESS_KEY'),
        secretAccessKey: env('R2_SECRET_KEY'),
        endpoint: env('R2_ENDPOINT'),
        region: env('R2_REGION', 'auto'),
        params: {
          Bucket: env('R2_BUCKET'),
          ACL: 'public-read',
        },
        baseUrl: env('R2_PUBLIC_URL')
      },
      actionOptions: {
        upload: {
          ACL: 'public-read',
          customPath: (file) => {
            // Obter a coleção associada ao arquivo
            let collection = 'geral';
            if (file.related) {
              // Extrair nome da coleção do campo relacionado
              collection = file.related.split('.')[0];
            }

            // Sanitizar o nome do arquivo
            const originalName = file.name ? file.name.substring(0, file.name.lastIndexOf('.')) : '';
            const sanitizedName = sanitizeString(originalName);

            // Adicionar hash curto para garantir unicidade
            const shortHash = file.hash ? file.hash.substring(0, 8) : '';

            // Retornar caminho com padrão: collection_filename-hash.ext
            return `${collection}/${collection}_${sanitizedName}-${shortHash}${file.ext}`;
          }
        }
      }
    },
  },
});

// Função auxiliar para sanitizar nomes de arquivos
function sanitizeString(str) {
  if (!str) return '';
  return str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remove acentos
    .replace(/[^a-zA-Z0-9-_]/g, '-') // Substitui caracteres especiais por hífen
    .replace(/-+/g, '-') // Remove hífens consecutivos
    .toLowerCase();
}



config\server.js

module.exports = ({ env }) => ({
  host: env('HOST', '0.0.0.0'),
  port: env.int('PORT', 1337),
  url: env('PUBLIC_URL', 'https://softmeat-backend-production.up.railway.app'),
  app: {
    keys: env.array('APP_KEYS'),
  },
  // Configurações de timeout
  emitErrors: false,
  maxUploadLimit: '50mb',
  maxRequestSize: '50mb',
  http2: {
    enabled: false,
  },
  webhooks: {
    populateRelations: false,
  },
  // Timeouts
  timeout: 120000,
});


config\webhooks.js

// config/webhooks.js
module.exports = {
  default: {
    'media.create': [
      {
        name: 'frontend-notification',
        url: process.env.FRONTEND_WEBHOOK_URL,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    ],
    'media.update': [
      {
        name: 'frontend-notification',
        url: process.env.FRONTEND_WEBHOOK_URL,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    ],
    'media.delete': [
      {
        name: 'frontend-notification',
        url: process.env.FRONTEND_WEBHOOK_URL,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    ],
  },
};


package.json

{
  "name": "backend",
  "private": true,
  "version": "0.1.0",
  "description": "A Strapi application",
  "scripts": {
    "develop": "strapi develop",
    "start": "NODE_ENV=production strapi start",
    "build": "strapi build",
    "strapi": "strapi"
  },
  "dependencies": {
    "@strapi/plugin-i18n": "4.12.0",
    "@strapi/plugin-users-permissions": "4.12.0",
    "@strapi/provider-upload-aws-s3": "^4.12.0",
    "@strapi/strapi": "4.12.0",
    "aws-sdk": "^2.1095.0",
    "better-sqlite3": "8.0.1",
    "pg": "^8.14.1",
    "pg-connection-string": "^2.7.0",
    "sharp": "^0.30.7",
    "strapi-plugin-import-export-entries": "^1.23.1"
  },
  "author": {
    "name": "A Strapi developer"
  },
  "strapi": {
    "uuid": "3289c097-8983-4dc0-817c-2192d4dfd468"
  },
  "engines": {
    "node": ">=14.19.1 <=18.x.x",
    "npm": ">=6.0.0"
  },
  "license": "MIT",
  "devDependencies": {
    "@aws-sdk/client-s3": "^3.188.0",
    "dotenv": "^16.4.7",
    "mime-types": "^2.1.35"
  }
}


src\admin\app.example.js

const config = {
  locales: [
    // 'ar',
    // 'fr',
    // 'cs',
    // 'de',
    // 'dk',
    // 'es',
    // 'he',
    // 'id',
    // 'it',
    // 'ja',
    // 'ko',
    // 'ms',
    // 'nl',
    // 'no',
    // 'pl',
    // 'pt-BR',
    // 'pt',
    // 'ru',
    // 'sk',
    // 'sv',
    // 'th',
    // 'tr',
    // 'uk',
    // 'vi',
    // 'zh-Hans',
    // 'zh',
  ],
};

const bootstrap = (app) => {
  console.log(app);
};

export default {
  config,
  bootstrap,
};


src\admin\app.js

const config = {
  locales: ['pt-BR'],
  translations: {
    'pt-BR': {
      'app.components.LeftMenu.navbrand.title': 'SoftMeat Dashboard',
      'Content Manager': 'Gerenciador de Conteúdo',
      'app.components.LeftMenu.collection.title': 'Tipos de Coleção',
      'Settings.permissions': 'Permissões',
      'Settings.roles': 'Funções',
      'Settings.users': 'Usuários',
      'notification.success.saved': 'Salvo com sucesso',
      'global.save': 'Salvar',
      'global.delete': 'Deletar',
      'global.back': 'Voltar',
      'global.cancel': 'Cancelar',
    },
  },
};


src\admin\webpack.config.example.js

'use strict';

/* eslint-disable no-unused-vars */
module.exports = (config, webpack) => {
  // Note: we provide webpack above so you should not `require` it
  // Perform customizations to webpack config
  // Important: return the modified config
  return config;
};


src\api\carrossel-treinamento\content-types\carrossel-treinamento\schema.json

{
  "kind": "collectionType",
  "collectionName": "carrossel_treinamentos",
  "info": {
    "singularName": "carrossel-treinamento",
    "pluralName": "carrossel-treinamentos",
    "displayName": "Carrossel Treinamento"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "DepoimentosTreinamentos": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": true
    }
  }
}


src\api\carrossel-treinamento\controllers\carrossel-treinamento.js

'use strict';

/**
 * carrossel-treinamento controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::carrossel-treinamento.carrossel-treinamento');


src\api\carrossel-treinamento\routes\carrossel-treinamento.js

'use strict';

/**
 * carrossel-treinamento router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::carrossel-treinamento.carrossel-treinamento');


src\api\carrossel-treinamento\services\carrossel-treinamento.js

'use strict';

/**
 * carrossel-treinamento service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::carrossel-treinamento.carrossel-treinamento');


src\api\cliente\content-types\cliente\schema.json

{
  "kind": "collectionType",
  "collectionName": "clientes",
  "info": {
    "singularName": "cliente",
    "pluralName": "clientes",
    "displayName": "Clientes"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true
    },
    "Logo": {
      "allowedTypes": [
        "images"
      ],
      "type": "media",
      "multiple": false,
      "required": true
    },
    
    "Descricao_Case": {
      "type": "string",
      "required": true
    }
  }
}


src\api\cliente\controllers\cliente.js

'use strict';

/**
 * cliente controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::cliente.cliente');


src\api\cliente\routes\cliente.js

'use strict';

/**
 * cliente router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::cliente.cliente');


src\api\cliente\services\cliente.js

'use strict';

/**
 * cliente service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::cliente.cliente');


src\api\configuracao-geral\content-types\configuracao-geral\schema.json

{
  "kind": "collectionType",
  "collectionName": "configuracao_gerais",
  "info": {
    "singularName": "configuracao-geral",
    "pluralName": "configuracao-gerais",
    "displayName": "Configuracao Geral"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "LogoNavegacao": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\configuracao-geral\controllers\configuracao-geral.js

'use strict';

/**
 * configuracao-geral controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::configuracao-geral.configuracao-geral');


src\api\configuracao-geral\routes\configuracao-geral.js

'use strict';

/**
 * configuracao-geral router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::configuracao-geral.configuracao-geral');


src\api\configuracao-geral\services\configuracao-geral.js

'use strict';

/**
 * configuracao-geral service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::configuracao-geral.configuracao-geral');


src\api\cronograma\content-types\cronograma\schema.json

{
  "kind": "collectionType",
  "collectionName": "cronogramas",
  "info": {
    "singularName": "cronograma",
    "pluralName": "cronogramas",
    "displayName": "Cronogramas",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Data": {
      "type": "date",
      "required": true
    },
    "Cidade": {
      "type": "string",
      "required": true,
      "default": "Ribeirão Preto"
    },
    "Vagas_Totais": {
      "type": "integer",
      "required": true
    },
    "Vagas_Disponiveis": {
      "type": "integer"
    },
    "Ativo": {
      "type": "boolean",
      "default": true,
      "required": true
    },



    "treinamento": {
      "type": "relation",
      "relation": "oneToOne",
      "target": "api::treinamento.treinamento"
    }
  }
}



src\api\cronograma\controllers\cronograma.js

'use strict';

/**
 * cronograma controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::cronograma.cronograma');


src\api\cronograma\routes\cronograma.js

'use strict';

/**
 * cronograma router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::cronograma.cronograma');


src\api\cronograma\services\cronograma.js

'use strict';

/**
 * cronograma service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::cronograma.cronograma');


src\api\curso-online\content-types\curso-online\schema.json

{
  "kind": "collectionType",
  "collectionName": "cursos_online",
  "info": {
    "singularName": "curso-online",
    "pluralName": "cursos-online",
    "displayName": "Cursos Online"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "slug": {
      "type": "uid",
      "targetField": "Nome",
      "required": true
    },
    "Categoria": {
      "type": "enumeration",
      "enum": [
        "Básico",
        "Intermediário",
        "Avançado",
        "Especialização"
      ]
    },
    "Descricao_Catalogo": {
      "type": "text",
      "required": true
    },
    "Descricao": {
      "type": "richtext",
      "required": true
    },
    "Link_Hotmart": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "Imagem": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": ["images"]
    },
    "Ordem_Exibicao": {
      "type": "integer",
      "default": 999
    },
    "Destaque": {
      "type": "boolean",
      "default": false,
      "required": true
    },
    "Meta_Title": {
      "type": "string"
    },
    "Meta_Description": {
      "type": "text"
    }
  }
}


src\api\curso-online\controllers\curso-online.js

'use strict';

/**
 * curso-online controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::curso-online.curso-online');


src\api\curso-online\routes\curso-online.js

'use strict';

/**
 * curso-online router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::curso-online.curso-online');


src\api\curso-online\services\curso-online.js

'use strict';

/**
 * curso-online service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::curso-online.curso-online');


src\api\hero-consultoria\content-types\hero-consultoria\schema.json

{
  "kind": "collectionType",
  "collectionName": "hero_consultorias",
  "info": {
    "singularName": "hero-consultoria",
    "pluralName": "hero-consultorias",
    "displayName": "Hero Consultoria"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Consultor": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\hero-consultoria\controllers\hero-consultoria.js

'use strict';

/**
 * hero-consultoria controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::hero-consultoria.hero-consultoria');


src\api\hero-consultoria\routes\hero-consultoria.js

'use strict';

/**
 * hero-consultoria router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::hero-consultoria.hero-consultoria');


src\api\hero-consultoria\services\hero-consultoria.js

'use strict';

/**
 * hero-consultoria service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::hero-consultoria.hero-consultoria');


src\api\home-consultoria\content-types\home-consultoria\schema.json

{
  "kind": "collectionType",
  "collectionName": "home_consultorias",
  "info": {
    "singularName": "home-consultoria",
    "pluralName": "home-consultorias",
    "displayName": "Home Consultoria"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "ConsultoriaPage": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\home-consultoria\controllers\home-consultoria.js

'use strict';

/**
 * home-consultoria controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::home-consultoria.home-consultoria');


src\api\home-consultoria\routes\home-consultoria.js

'use strict';

/**
 * home-consultoria router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::home-consultoria.home-consultoria');


src\api\home-consultoria\services\home-consultoria.js

'use strict';

/**
 * home-consultoria service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::home-consultoria.home-consultoria');


src\api\home-hero\content-types\home-hero\schema.json

{
  "kind": "collectionType",
  "collectionName": "home_heroes",
  "info": {
    "singularName": "home-hero",
    "pluralName": "home-heroes",
    "displayName": "Home Hero",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "PageHero": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ]
    }
  }
}


src\api\home-hero\controllers\home-hero.js

'use strict';

/**
 * home-hero controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::home-hero.home-hero');


src\api\home-hero\routes\home-hero.js

'use strict';

/**
 * home-hero router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::home-hero.home-hero');


src\api\home-hero\services\home-hero.js

'use strict';

/**
 * home-hero service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::home-hero.home-hero');


src\api\home-treinamento\content-types\home-treinamento\schema.json

{
  "kind": "collectionType",
  "collectionName": "home_treinamentos",
  "info": {
    "singularName": "home-treinamento",
    "pluralName": "home-treinamentos",
    "displayName": "Home Treinamento"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "TreinamentoPage": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": false
    }
  }
}


src\api\home-treinamento\controllers\home-treinamento.js

'use strict';

/**
 * home-treinamento controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::home-treinamento.home-treinamento');


src\api\home-treinamento\routes\home-treinamento.js

'use strict';

/**
 * home-treinamento router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::home-treinamento.home-treinamento');


src\api\home-treinamento\services\home-treinamento.js

'use strict';

/**
 * home-treinamento service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::home-treinamento.home-treinamento');


src\api\index-destaque\content-types\index-destaque\schema.json

{
  "kind": "singleType",
  "collectionName": "index_destaques",
  "info": {
    "singularName": "index-destaque",
    "pluralName": "index-destaques",
    "displayName": "Index Destaques",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "cursos_em_destaque": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::curso-online.curso-online"
    },
    "Imagem": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": ["images"]
    },
    "produtos_em_destaque": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::produto.produto"
    }
  }
}


src\api\index-destaque\controllers\index-destaque.js

'use strict';

/**
 * index-destaque controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::index-destaque.index-destaque');


src\api\index-destaque\routes\index-destaque.js

'use strict';

/**
 * index-destaque router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::index-destaque.index-destaque');


src\api\index-destaque\services\index-destaque.js

'use strict';

/**
 * index-destaque service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::index-destaque.index-destaque');


src\api\media-reference\controllers\media-reference.js

// src/api/media-reference/controllers/media-reference.js
'use strict';

module.exports = {
  async reference(ctx) {
    try {
      const { url, name, caption, alternativeText } = ctx.request.body;

      if (!url) {
        return ctx.badRequest('URL é obrigatória');
      }

      // Criar o objeto de referência
      const fileData = {
        fileInfo: {
          name: name || url.split('/').pop(),
          url,
          caption,
          alternativeText,
          isExternalUrl: true
        }
      };

      // Usar o serviço de upload existente
      const file = await strapi.plugins.upload.services.upload.upload(fileData);

      return {
        success: true,
        file
      };
    } catch (error) {
      console.error('[Media Reference] Erro:', error);
      return ctx.badRequest('Erro ao referenciar mídia', { error: error.message });
    }
  }
};


src\api\media-reference\routes\media-reference.js

// src/api/media-reference/routes/media-reference.js
'use strict';

module.exports = {
  routes: [
    {
      method: 'POST',
      path: '/api/media/reference',
      handler: 'media-reference.reference',
      config: {
        policies: [],
        description: 'Referencia uma mídia externa por URL'
      }
    }
  ]
};


src\api\produto\content-types\produto\schema.json

{
  "kind": "collectionType",
  "collectionName": "produtos",
  "info": {
    "singularName": "produto",
    "pluralName": "produtos",
    "displayName": "Produtos",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "slug": {
      "type": "uid",
      "targetField": "Nome"
    },
    "Categoria": {
      "type": "enumeration",
      "enum": [
        "Maturados",
        "Fermentados",
        "Defumados",
        "Cozidos",
        "Frescais"
      ],
      "required": true
    },
    "Descricao_Catalogo": {
      "type": "string",
      "required": true
    },
    "Descricao": {
      "type": "richtext",
      "required": true
    },
    "Link_Mercado_Livre": {
      "type": "string",
      "required": true,
      "unique": true
    },
    "Imagem": {
      "type": "media",
      "multiple": true,
      "required": false,
      "allowedTypes": [
        "images"
      ]
    },
    "Destaque": {
      "type": "boolean",
      "default": false,
      "required": true
    },
    "Meta_File": {
      "type": "string"
    },
    "Meta_Description": {
      "type": "text"
    },
    "Disponivel": {
      "type": "boolean",
      "default": true,
      "required": true
    }
  }
}


src\api\produto\controllers\produto.js

'use strict';

/**
 * produto controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::produto.produto');


src\api\produto\routes\produto.js

'use strict';

/**
 * produto router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::produto.produto');


src\api\produto\services\produto.js

'use strict';

/**
 * produto service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::produto.produto');


src\api\sobre-carrossel\content-types\sobre-carrossel\schema.json

{
  "kind": "collectionType",
  "collectionName": "sobre_carrosseis",
  "info": {
    "singularName": "sobre-carrossel",
    "pluralName": "sobre-carrosseis",
    "displayName": "Sobre Carrossel"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Titulo": {
      "type": "string"
    },
    "Imagens": {
      "allowedTypes": [
        "images",
        "files",
        "videos",
        "audios"
      ],
      "type": "media",
      "multiple": true
    }
  }
}


src\api\sobre-carrossel\controllers\sobre-carrossel.js

'use strict';

/**
 * sobre-carrossel controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::sobre-carrossel.sobre-carrossel');


src\api\sobre-carrossel\routes\sobre-carrossel.js

'use strict';

/**
 * sobre-carrossel router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::sobre-carrossel.sobre-carrossel');


src\api\sobre-carrossel\services\sobre-carrossel.js

'use strict';

/**
 * sobre-carrossel service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::sobre-carrossel.sobre-carrossel');


src\api\testemunho\content-types\testemunho\schema.json

{
  "kind": "collectionType",
  "collectionName": "testemunhos",
  "info": {
    "singularName": "testemunho",
    "pluralName": "testemunhos",
    "displayName": "Testemunhos"
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true
    },
    "Imagem": {
      "type": "media",
      "multiple": false,
      "required": false,
      "allowedTypes": ["images"]
    },
    "Foto": {
      "allowedTypes": [
        "images"
      ],
      "type": "media",
      "multiple": false,
      "required": true
    },
    "Depoimento": {
      "type": "text"
    },
    "curso_realizado": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::treinamento.treinamento"
    },
    "LinkedIn": {
      "type": "string"
    },
    "Instagram": {
      "type": "string"
    },
    "Facebook": {
      "type": "string"
    },
    "Cargo": {
      "type": "string"
    },
    "Empresa": {
      "type": "string"
    },
    "Ativo": {
      "type": "boolean",
      "default": true
    }
  }
}


src\api\testemunho\controllers\testemunho.js

'use strict';

/**
 * testemunho controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::testemunho.testemunho');


src\api\testemunho\routes\testemunho.js

'use strict';

/**
 * testemunho router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::testemunho.testemunho');


src\api\testemunho\services\testemunho.js

'use strict';

/**
 * testemunho service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::testemunho.testemunho');


src\api\treinamento\content-types\treinamento\schema.json

{
  "kind": "collectionType",
  "collectionName": "treinamentos",
  "info": {
    "singularName": "treinamento",
    "pluralName": "treinamentos",
    "displayName": "Treinamentos",
    "description": ""
  },
  "options": {
    "draftAndPublish": true
  },
  "pluginOptions": {},
  "attributes": {
    "Nome": {
      "type": "string",
      "required": true
    },
    "Nivel": {
      "type": "enumeration",
      "enum": [
        "Basico",
        "Intermediario",
        "Avancado"
      ],
      "required": true
    },
    "Duracao": {
      "type": "integer",
      "required": true,
      "default": 1
    },
    "Descricao_Catalogo": {
      "type": "text",
      "required": true
    },
    "Topicos": {
      "type": "richtext",
      "required": true
    },
    "Ativo": {
      "type": "boolean",
      "default": false,
      "required": true
    },
    "Ordem": {
      "type": "integer"
    },
    "Meta_Title": {
      "type": "text"
    },
    "Meta_Description": {
      "type": "text"
    }
  }
}


src\api\treinamento\controllers\treinamento.js

'use strict';

/**
 * treinamento controller
 */

const { createCoreController } = require('@strapi/strapi').factories;

module.exports = createCoreController('api::treinamento.treinamento');


src\api\treinamento\routes\treinamento.js

'use strict';

/**
 * treinamento router
 */

const { createCoreRouter } = require('@strapi/strapi').factories;

module.exports = createCoreRouter('api::treinamento.treinamento');


src\api\treinamento\services\treinamento.js

'use strict';

/**
 * treinamento service
 */

const { createCoreService } = require('@strapi/strapi').factories;

module.exports = createCoreService('api::treinamento.treinamento');


src\extensions\upload\services\Upload.js

// src/extensions/upload/services/Upload.js
'use strict';

const path = require('path');

module.exports = {
  async enhanceFile(file, fileInfo = {}, metas = {}) {
    const originalEnhancer = strapi.plugin('upload').service('file');
    const fileInfoEnhanced = await originalEnhancer.enhanceFile(file, fileInfo, metas);

    // Personalizar o nome do arquivo para seguir o padrão "nome da coleção_nome da imagem"
    if (metas.refId && metas.ref && metas.field) {
      try {
        const model = strapi.contentTypes[metas.ref];
        if (model) {
          const modelName = model.info.singularName || model.info.name;
          const extension = path.extname(fileInfoEnhanced.name);
          const baseName = path.basename(fileInfoEnhanced.name, extension);
          const sanitizedName = this.sanitizeString(baseName);
          const shortHash = fileInfoEnhanced.hash.substring(0, 8);

          // Formatar nome do arquivo conforme padrão desejado
          fileInfoEnhanced.name = `${modelName}_${sanitizedName}-${shortHash}${extension}`;

          // Armazenar metadados adicionais
          fileInfoEnhanced.provider_metadata = {
            ...fileInfoEnhanced.provider_metadata,
            collection: modelName,
            originalName: baseName
          };
        }
      } catch (error) {
        console.error('Error customizing file name:', error);
      }
    }

    return fileInfoEnhanced;
  },

  sanitizeString(str) {
    if (!str) return '';
    return str
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-zA-Z0-9-_]/g, '-')
      .replace(/-+/g, '-')
      .toLowerCase();
  }
};



src\extensions\upload\strapi-server.js

// src/extensions/upload/strapi-server.js
module.exports = (plugin) => {
  plugin.services.upload.uploadToEntity = async (params) => {
    console.log('[Upload Debug] Params:', JSON.stringify(params, null, 2));
    return await plugin.services.upload.uploadToEntity(params);
  };

  return plugin;
};


src\index.js

// src/index.js
module.exports = {
  register(strapi) {
    console.log('=== VERIFICAÇÃO DE AMBIENTE DE PRODUÇÃO ===');
    console.log('NODE_ENV:', process.env.NODE_ENV);
    console.log('DATABASE_CLIENT:', process.env.DATABASE_CLIENT);
    console.log('DATABASE_FILENAME:', process.env.DATABASE_FILENAME);

    console.log('=== CONFIGURAÇÃO R2 ===');
    console.log('R2_ACCESS_KEY configurado:', !!process.env.R2_ACCESS_KEY);
    console.log('R2_SECRET_KEY configurado:', !!process.env.R2_SECRET_KEY);
    console.log('R2_ENDPOINT:', process.env.R2_ENDPOINT);
    console.log('R2_BUCKET:', process.env.R2_BUCKET);
    console.log('R2_PUBLIC_URL:', process.env.R2_PUBLIC_URL);

    // Verificar permissões de diretório apenas se estiver usando SQLite
    if (process.env.NODE_ENV === 'production' &&
        process.env.DATABASE_CLIENT === 'sqlite' &&
        process.env.DATABASE_FILENAME) {
      const fs = require('fs');
      const path = require('path');

      const dbPath = process.env.DATABASE_FILENAME;
      const dbDir = path.dirname(dbPath);

      try {
        // Resto do código de verificação do SQLite...
      } catch (error) {
        console.error('Erro ao verificar banco de dados:', error.message);
      }
    }
  },

  bootstrap(strapi) {
    console.log(`Strapi iniciado em ${process.env.NODE_ENV} mode`);
  }
};


src\middlewares\upload-debug.js

module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    if (ctx.request.url.includes('/upload') && ctx.request.method === 'POST') {
      console.log('=== INTERCEPTANDO REQUISIÇÃO DE UPLOAD ===');
      console.log('Tamanho do corpo:', ctx.request.body ? 'Presente' : 'Ausente');
      console.log('Content-Type:', ctx.request.headers['content-type']);
      console.log('Content-Length:', ctx.request.headers['content-length']);

      try {
        await next();

        console.log('=== RESPOSTA DE UPLOAD ===');
        console.log('Status:', ctx.response.status);
        console.log('Tipo de resposta:', typeof ctx.response.body);
      } catch (error) {
        console.error('=== ERRO NO UPLOAD ===');
        console.error('Mensagem:', error.message);
        console.error('Stack:', error.stack);
        throw error;
      }
    } else {
      await next();
    }
  };
};


src\middlewares\upload-logger.js

// src/middlewares/upload-logger.js
module.exports = (config, { strapi }) => {
  return async (ctx, next) => {
    if (ctx.request.url.includes('/upload')) {
      console.log('=== UPLOAD DEBUG ===');
      console.log('Request method:', ctx.request.method);
      console.log('Content-Type:', ctx.request.header['content-type']);

      try {
        await next();
        console.log('Upload response status:', ctx.response.status);
      } catch (error) {
        console.error('Upload error:', error.message);
        console.error('Error stack:', error.stack);
        throw error;
      }
    } else {
      await next();
    }
  };
};


src\provider\r2-upload\index.js

// src/providers/r2-upload/index.js
const AWS = require('aws-sdk');
const path = require('path');

module.exports = {
  init(config) {
    const S3 = new AWS.S3({
      accessKeyId: config.accessKeyId,
      secretAccessKey: config.secretAccessKey,
      endpoint: config.endpoint,
      region: config.region || 'auto',
      s3ForcePathStyle: true,
      signatureVersion: 'v4',
    });

    const publicUrl = config.publicUrl || config.endpoint;

    return {
      async upload(file) {
        const { buffer, hash, ext, mime } = file;

        // Gerar nome de arquivo com hash para evitar colisões
        const filename = `${hash}${ext}`;

        // Definir categoria baseada no mime-type
        let category = 'other';
        if (mime.startsWith('image/')) category = 'images';
        else if (mime.startsWith('video/')) category = 'videos';
        else if (mime.startsWith('audio/')) category = 'audio';

        // Definir chave com categoria
        const Key = `${category}/${filename}`;

        // Upload para R2
        await S3.upload({
          Key,
          Body: Buffer.from(buffer),
          ContentType: mime,
          Bucket: config.bucket,
          ACL: 'public-read'
        }).promise();

        // Formar URL pública correta
        const cleanPublicUrl = publicUrl.endsWith('/')
          ? publicUrl.slice(0, -1)
          : publicUrl;

        file.url = `${cleanPublicUrl}/${Key}`;

        return file;
      },

      async delete(file) {
        // Extrair a chave da URL
        const urlPath = new URL(file.url).pathname;
        const Key = urlPath.startsWith('/') ? urlPath.substring(1) : urlPath;

        try {
          await S3.deleteObject({
            Key,
            Bucket: config.bucket,
          }).promise();
        } catch (error) {
          console.error('Error deleting from R2:', error);
        }
      },
    };
  },
};


src\utils\r2.js

// src/utils/r2.js - versão melhorada
'use strict';

/**
 * Utilitários para manipulação de URLs do Cloudflare R2
 */

/**
 * Formata um caminho de arquivo para uma URL R2 completa
 * @param {string} path - Caminho relativo do arquivo no bucket
 * @returns {string} URL formatada
 */
const formatR2Url = (path) => {
  if (!path) return '';

  // Sanitizar o caminho
  const cleanPath = String(path).startsWith('/') ? path.substring(1) : path;

  // Usar domínio personalizado se disponível
  if (process.env.CF_PUBLIC_ACCESS_URL) {
    const domain = process.env.CF_PUBLIC_ACCESS_URL.endsWith('/')
      ? process.env.CF_PUBLIC_ACCESS_URL.slice(0, -1)
      : process.env.CF_PUBLIC_ACCESS_URL;
    return `${domain}/${cleanPath}`;
  }

  // Fallback para URL direta do R2
  if (process.env.CF_ENDPOINT && process.env.CF_BUCKET) {
    const endpoint = process.env.CF_ENDPOINT.endsWith('/')
      ? process.env.CF_ENDPOINT.slice(0, -1)
      : process.env.CF_ENDPOINT;
    return `${endpoint}/${process.env.CF_BUCKET}/${cleanPath}`;
  }

  // Se tudo falhar, retornar o caminho como está
  console.warn('[R2 URL Formatter] Configuração R2 incompleta, usando caminho original');
  return path;
};

module.exports = {
  formatR2Url
};


src\utils\r2Helper.js

'use strict';

/**
 * Utilitários para auxiliar no tratamento de URLs do R2
 */

const isR2Url = (url) => {
  if (!url) return false;

  const r2Patterns = [
    'images.softmeat.com.br',
    '.r2.cloudflarestorage.com',
    process.env.CF_PUBLIC_ACCESS_URL,
    process.env.R2_CUSTOM_DOMAIN
  ].filter(Boolean);

  return r2Patterns.some(pattern => pattern && url.includes(pattern));
};

const formatR2Url = (url) => {
  if (!url || !isR2Url(url)) return url;

  // Se já estiver usando o domínio público, retornar como está
  if (process.env.CF_PUBLIC_ACCESS_URL && url.includes(process.env.CF_PUBLIC_ACCESS_URL)) {
    return url;
  }

  // Se estiver usando o endpoint direto do R2, converter para domínio público
  if (process.env.CF_ENDPOINT && process.env.CF_BUCKET && url.includes(process.env.CF_ENDPOINT)) {
    const publicUrl = process.env.CF_PUBLIC_ACCESS_URL;
    if (!publicUrl) return url;

    const cleanPublicUrl = publicUrl.endsWith('/') ? publicUrl.slice(0, -1) : publicUrl;

    // Extrair o caminho do objeto no bucket
    const regex = new RegExp(`.*?${process.env.CF_BUCKET}/?(.*)`, 'i');
    const match = url.match(regex);

    if (match && match[1]) {
      return `${cleanPublicUrl}/${match[1]}`;
    }
  }

  return url;
};

module.exports = {
  isR2Url,
  formatR2Url
};


